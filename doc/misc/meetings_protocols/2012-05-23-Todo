* Niels: Rewriting: Bei Elimination von Negationen direkt auf <= erzeugen.

* Karsten: Abfrage vor Tiefensuche, ob Wert konstant

* Syntax: FIREABLE(t) AND p >= 0

Statepredicate -> FORMULA ...
Deadlock
Liveness
LTL-Ausschnitt FG GF F
CTL
Reversibility
Boundedness
Boundedplace
Deadtransition -> Atomic Proposition "FIREABLE" in FORMULA
Homestates


Neu:

REACHABLE (EF) / INVARIANT (AG) / IMPOSSIBLE (AG NOT) -> Statepredicate

FORMULA



EF (FIREABLE(t))
EXPATH EVENTUALLY FIREABLE(t)
REACHABLE FIREABLE(t)

AG NOT DEADLOCK
ALLPATH ALWAYS (NOT DEADLOCK XOR 1=3*p4)




* Andreas:

// copy initial marking into current marking
memcpy(Marking::Current, Marking::Initial, Net::Card[PL] * SIZEOF_INDEX_T);
Marking::HashCurrent = Marking::HashInitial;

in Funktion auslagern.



* Karsten: Deadlocks und Findpath

* Karsten: Findpath und Zeugenpfad

* Karsten: Transitionsauswahl auslagern wie bei Store

* Niels: Dreiwertige Logik f√ºr Ausgaben (Bloom, Findpath, Memory-Overflow, ...)

