/* translation of file(s)
	"Frontend/Parser/formula_abstract.k"
	"Frontend/Parser/formula_rewrite.k"
	"Frontend/Parser/formula_unparse.k"
 */
/* generated by:
 *  @(#)$Author: Kimwitu++ version 2.3.13 (C) 1998-2008 Humboldt-Universitaet zu Berlin $
 */
#define KC_UNPARSE

#include <stdio.h>
#include <string>
#include <stdlib.h>
#include "ast-system-k.h"
#include "ast-system-unpk.h"


namespace kc {
base_uview_class base_uview;
out_class out;
count_class count;
elem_class elem;
temporal_class temporal;
internal_class internal;
buechi_class buechi;
ctl_class ctl;
ltl_class ltl;
toplevelboolean_class toplevelboolean;
compound_class compound;
detectcompound_class detectcompound;
hl_staticanalysis_class hl_staticanalysis;
visible_class visible;

impl_uviews uviews[] = {
    {"base_uview",&base_uview},
    {"out",&out},
    {"count",&count},
    {"elem",&elem},
    {"temporal",&temporal},
    {"internal",&internal},
    {"buechi",&buechi},
    {"ctl",&ctl},
    {"ltl",&ltl},
    {"toplevelboolean",&toplevelboolean},
    {"compound",&compound},
    {"detectcompound",&detectcompound},
    {"hl_staticanalysis",&hl_staticanalysis},
    {"visible",&visible},
    {0,0}
};

} // namespace kc
namespace kc { }
using namespace kc;
/* included stuff */
#line 19 "Frontend/Parser/formula_unparse.k"
// LCOV_EXCL_START
/*!
\brief printer-function for Kimiwtu's output on stdout

To use an unparser in Kimwitu++, a function with this signature needs to be
passed to the unparse() function.

\param[in] s  string to print

\note This function is not "found" by the code coverage detection and is hence
hidden from it.
*/
void myprinter(const char *s, kc::uview)
{
    printf("%s", s);
}
// LCOV_EXCL_STOP

/// result string for stringprinter
std::string unparsed;

// LCOV_EXCL_START
/*!
\brief printer-function for Kimiwtu's output to a string object

To use an unparser in Kimwitu++, a function with this signature needs to be
passed to the unparse() function.

\param[in] s  string to add

\note This function is not "found" by the code coverage detection and is hence
hidden from it.
\post Output is written to string unparsed which can be accessed wherever an
unparser can be used. You need to clear the string after use to avoid keeping
old data.
*/
void stringprinter(const char *s, kc::uview)
{
    unparsed += s;
}
// LCOV_EXCL_STOP

bool *place_in_formula = NULL;
unsigned int places_mentioned = 0;
unsigned int unique_places_mentioned = 0;

#line  104 "ast-system-unpk.cc"
#line 711 "Frontend/Parser/formula_unparse.k"
#include <config.h>
#include <Core/Dimensions.h>
#include <Formula/StatePredicate/AtomicStatePredicate.h>
#include <Formula/StatePredicate/ConjunctionStatePredicate.h>
#include <Formula/StatePredicate/DisjunctionStatePredicate.h>
#include <Formula/StatePredicate/FalsePredicate.h>
#include <Formula/StatePredicate/StatePredicate.h>
#include <Formula/StatePredicate/TruePredicate.h>
#include <Net/Marking.h>
#include <Net/Net.h>

#include <map>
#include <vector>
#include <stack>

// mapping from node ids to factors
std::map<int, int> current;

// mapping from tree node ids to list of intermediate formulas
std::map<int, std::vector<StatePredicate *> > formulas;

// invariant: top is always my parent
std::stack<size_t> id_stack;

// next free id
size_t nextId = 0;

#line  133 "ast-system-unpk.cc"
#line 879 "Frontend/Parser/formula_unparse.k"
std::map<uint32_t, std::vector<std::pair<uint32_t,uint32_t> > > transitions ;
std::set<uint32_t> acceptingset;
std::map<uint32_t, StatePredicate*> predicates;
std::map<uint32_t, uint32_t> states_to_interal;

uint32_t get_state_number(uint32_t state){
    if (states_to_interal.find(state) == states_to_interal.end()){
	// get a new state number
	uint32_t new_state_number = states_to_interal.size();
	states_to_interal[state] = new_state_number;
	return new_state_number;
    }
    return states_to_interal[state];
}

#line  150 "ast-system-unpk.cc"
#line 983 "Frontend/Parser/formula_unparse.k"

#include <Core/Dimensions.h>
#include <Exploration/StatePredicateProperty.h>
#include <Formula/CTL/AUFormula.h>
#include <Formula/CTL/AXFormula.h>
#include <Formula/CTL/AtomicFormula.h>
#include <Formula/CTL/CTLFormula.h>
#include <Formula/CTL/ConjunctionFormula.h>
#include <Formula/CTL/DisjunctionFormula.h>
#include <Formula/CTL/EUFormula.h>
#include <Formula/CTL/EXFormula.h>
#include <Formula/CTL/NotFormula.h>
#include <Net/Net.h>

#include <map>
#include <vector>
#include <stack>

// mapping from node ids to factors
std::map<int, int> ctl_current;

// mapping from tree node ids to list of intermediate formulas
std::map<int, std::vector<CTLFormula_p> > ctl_formulas;

// invariant: top is always my parent
std::stack<size_t> ctl_id_stack;

// next free id
size_t ctl_nextId = 0;

// needs dfs-storage;
size_t ctl_dfs_id = 0;

// needs cached results id
size_t ctl_result_cache_id = 0;

// temporal storage to be able to include the LessEqualStatePredicate into an AtomicFormula
StatePredicateProperty* spp;

#line  191 "ast-system-unpk.cc"
#line 1195 "Frontend/Parser/formula_unparse.k"
#include <Core/Runtime.h>
#include <Frontend/Parser/ast-system-rk.h>
#include <vector>

std::vector<LTLTree_p> ltlstack;

#line  199 "ast-system-unpk.cc"
#line 1412 "Frontend/Parser/formula_unparse.k"
#include <Core/Runtime.h>
#include <Frontend/Parser/ast-system-rk.h>
#include <vector>
#include <Planning/Task.h>
#include <Planning/ConjunctionTask.h>
#include <Planning/DisjunctionTask.h>
#include <Planning/LeafTask.h>

#line  209 "ast-system-unpk.cc"
#line 1467 "Frontend/Parser/formula_unparse.k"
#include <Core/Runtime.h>
#include <Frontend/Parser/ast-system-rk.h>
#include <vector>
#include <Planning/Task.h>
#include <Planning/CompoundTask.h>
#include <Planning/LeafTask.h>

#line  218 "ast-system-unpk.cc"
#line 1522 "Frontend/Parser/formula_unparse.k"
#include <Core/Runtime.h>
#include <Frontend/Parser/ast-system-rk.h>
#include <vector>
#include <Planning/Task.h>
#include <Planning/CompoundTask.h>

#line  226 "ast-system-unpk.cc"
/* end included stuff */


namespace kc {

#ifndef KC_TRACE_PROVIDED
#define KC_TRACE_PROVIDED(COND,FILE,LINE,NODE) COND
#endif

void
impl_abstract_phylum::unparse(printer_function opf, uview uv)
{
    printer_functor_function_wrapper pf(opf);
    do_unparse(pf, uv);
}

// Everything given as a pointer is expected to have an unparse-method (we
// believe it's a phylum), unless there's a specialisation for it

void
unparse(abstract_phylum kc_p, printer_functor kc_printer, uview kc_current_view)
{
    kc_p->unparse(kc_printer, kc_current_view);
}

void
unparse(void *kc_p, printer_functor kc_printer, uview kc_current_view)
{
    // MPi: 20020628 there shouldn't be any left
    assertionFailed("Unparse called for untyped pointer");
    // MPi: cast should be unnecessary, but there are still void*
    reinterpret_cast<impl_abstract_phylum*>(kc_p)->unparse(kc_printer, kc_current_view);
}

void
unparse(int kc_v, printer_functor kc_printer, uview kc_current_view)
{
    kc_char_t kc_string[200];
    kc_print_integer(kc_string, kc_v);
    kc_printer(kc_string, kc_current_view);
}

void
unparse(double kc_v, printer_functor kc_printer, uview kc_current_view)
{
    kc_char_t kc_string[200];
    kc_print_real(kc_string, kc_v);
    kc_printer(kc_string, kc_current_view);
}

void
unparse(kc_char_t *kc_v, printer_functor kc_printer, uview kc_current_view)
{
    kc_printer(kc_v, kc_current_view);
}

void
unparse(kc_string_t kc_v, printer_functor kc_printer, uview kc_current_view)
{
    kc_printer(kc_v.c_str(), kc_current_view);
}

#line  289 "ast-system-unpk.cc"
void
impl_abstract_phylum::default_unparse(printer_functor kc_printer, uview kc_current_view)
{
    register int no_sons = operator_info[prod_sel()].no_sons;
    for (int i=0; i < no_sons; i++)
    subphylum(i)->unparse(kc_printer, kc_current_view);
}

void
impl_casestring__Str::do_unparse(printer_functor kc_printer, uview kc_current_view)
{
    kc::unparse(name, kc_printer, kc_current_view);
}

void
impl_nocasestring_NoCaseStr::do_unparse(printer_functor kc_printer, uview kc_current_view)
{
    kc::unparse(name, kc_printer, kc_current_view);
}

void
impl_integer__Int::do_unparse(printer_functor kc_printer, uview kc_current_view)
{
    kc::unparse(value, kc_printer, kc_current_view);
}

void
impl_real__Real::do_unparse(printer_functor kc_printer, uview kc_current_view)
{
    kc::unparse(value, kc_printer, kc_current_view);
}

void
impl_voidptr__VoidPtr::do_unparse(printer_functor kc_printer, uview kc_current_view)
{
    kc::unparse(pointer, kc_printer, kc_current_view);
}


#line  329 "ast-system-unpk.cc"
void
impl_tFormula_Compound::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case visible_enum: {
	    visible_class& kc_current_view=static_cast<visible_class&>(kc_current_view_base);
	    {
#line 1964 "Frontend/Parser/formula_unparse.k"
		const tFormula x = this->tFormula_1;
#line 1964 "Frontend/Parser/formula_unparse.k"
		const tFormula y = this->tFormula_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 1965 "Frontend/Parser/formula_unparse.k"

		containsNext = (x -> containsNext || y -> containsNext);

#line  347 "ast-system-unpk.cc"
	    }
	    break;
	}
	case detectcompound_enum: {
	    detectcompound_class& kc_current_view=static_cast<detectcompound_class&>(kc_current_view_base);
	    {
#line 1530 "Frontend/Parser/formula_unparse.k"
		const tFormula f = this/**/;
#line 1530 "Frontend/Parser/formula_unparse.k"
		const tFormula x = this->tFormula_1;
#line 1530 "Frontend/Parser/formula_unparse.k"
		const tFormula y = this->tFormula_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 1531 "Frontend/Parser/formula_unparse.k"

		f->type = FORMULA_COMPOUND;

#line  366 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1476 "Frontend/Parser/formula_unparse.k"
		const tFormula f = this/**/;
#line 1476 "Frontend/Parser/formula_unparse.k"
		const tFormula x = this->tFormula_1;
#line 1476 "Frontend/Parser/formula_unparse.k"
		const tFormula y = this->tFormula_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 1477 "Frontend/Parser/formula_unparse.k"

		f->task = new CompoundTask(x->task,y->task);

#line  385 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 236 "Frontend/Parser/formula_unparse.k"
		const tFormula f = this/**/;
#line 236 "Frontend/Parser/formula_unparse.k"
		const tFormula x = this->tFormula_1;
#line 236 "Frontend/Parser/formula_unparse.k"
		const tFormula y = this->tFormula_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 237 "Frontend/Parser/formula_unparse.k"

		f -> type = FORMULA_COMPOUND; 
		f -> cannotcompute = x -> cannotcompute || y -> cannotcompute;

#line  405 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 194 "Frontend/Parser/formula_unparse.k"
		const tFormula x = this->tFormula_1;
#line 194 "Frontend/Parser/formula_unparse.k"
		const tFormula y = this->tFormula_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 151 "Frontend/Parser/formula_unparse.k"
		const tFormula x = this->tFormula_1;
#line 151 "Frontend/Parser/formula_unparse.k"
		const tFormula y = this->tFormula_2;
#line 151 "Frontend/Parser/formula_unparse.k"
		x->fs=fs;
#line  430 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 151 "Frontend/Parser/formula_unparse.k"
		y->fs=x->fs;
#line  434 "ast-system-unpk.cc"
		kc::unparse(y, kc_printer, kc_current_view);
#line 151 "Frontend/Parser/formula_unparse.k"
		fs=y->fs;
#line  438 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 86 "Frontend/Parser/formula_unparse.k"
		const tFormula x = this->tFormula_1;
#line 86 "Frontend/Parser/formula_unparse.k"
		const tFormula y = this->tFormula_2;
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" : "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  456 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  469 "ast-system-unpk.cc"
void
impl_tFormula_CompBound::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1481 "Frontend/Parser/formula_unparse.k"
		const tFormula f = this/**/;
#line 1482 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  483 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 242 "Frontend/Parser/formula_unparse.k"
		const tFormula f = this/**/;
#line 243 "Frontend/Parser/formula_unparse.k"

		f -> type = FORMULA_BOUND; 
		f -> cannotcompute = false;

#line  497 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 195 "Frontend/Parser/formula_unparse.k"
		const tFormula c = this/**/;
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 152 "Frontend/Parser/formula_unparse.k"
		const tFormula c = this/**/;
#line 152 "Frontend/Parser/formula_unparse.k"
		fs=c->formula->count(fs);fs->comp--;
#line  516 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 87 "Frontend/Parser/formula_unparse.k"
		const tFormula c = this/**/;
		{ kc_printer(kc_t("MAX("), kc_current_view); }
#line 87 "Frontend/Parser/formula_unparse.k"
		kc_printer(((AtomicStatePredicate *)(c->formula))->toCompString(),kc_current_view);
#line  528 "ast-system-unpk.cc"
			{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  534 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  546 "ast-system-unpk.cc"
void
impl_tFormula_StatePredicateFormula::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case visible_enum: {
	    visible_class& kc_current_view=static_cast<visible_class&>(kc_current_view_base);
	    {
#line 1954 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 1955 "Frontend/Parser/formula_unparse.k"

		for(arrayindex_t i = 0; i < Net::Card[TR]; i++)
		{
		    Transition::Visible[i] = false;
		}

#line  563 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 1961 "Frontend/Parser/formula_unparse.k"

		containsNext = x -> containsNext;

#line  569 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1486 "Frontend/Parser/formula_unparse.k"
		const tFormula f = this/**/;
#line 1487 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  582 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    {
#line 1421 "Frontend/Parser/formula_unparse.k"
		const tFormula f = this/**/;
#line 1421 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 1422 "Frontend/Parser/formula_unparse.k"

		f->task = x->task;

#line  598 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ltl_enum: {
	    ltl_class& kc_current_view=static_cast<ltl_class&>(kc_current_view_base);
	    {
#line 1203 "Frontend/Parser/formula_unparse.k"
		const tFormula f = this/**/;
#line 1203 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 1205 "Frontend/Parser/formula_unparse.k"


		f->ltl_tree = bin_simpler(push_negation(tl_nn(NOT, ltlstack.back(), NULL)));


#line  616 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ctl_enum: {
	    ctl_class& kc_current_view=static_cast<ctl_class&>(kc_current_view_base);
	    {
#line 1060 "Frontend/Parser/formula_unparse.k"
		const tFormula f = this/**/;
#line 1060 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 1060 "Frontend/Parser/formula_unparse.k"

		f->unparse(myprinter, kc::temporal);

		ctl_id_stack.push(ctl_nextId++);

#line  633 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 1066 "Frontend/Parser/formula_unparse.k"

		ctl_nextId = ctl_id_stack.top();
		ctl_id_stack.pop();


		assert(ctl_nextId == 0);
		f->ctl_formula = ctl_formulas[0][0];
		f->ctl_formula->payloadsize = ctl_dfs_id*SIZEOF_STATENUMBER_T + (2*ctl_result_cache_id+7)/8;

#line  645 "ast-system-unpk.cc"
	    }
	    break;
	}
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    {
#line 739 "Frontend/Parser/formula_unparse.k"
		const tFormula f = this/**/;
#line 739 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 739 "Frontend/Parser/formula_unparse.k"


		current.clear();
		formulas.clear();
		while (not id_stack.empty())
		id_stack.pop();
		nextId = 0;
		id_stack.push(nextId++);

#line  666 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 749 "Frontend/Parser/formula_unparse.k"

		nextId = id_stack.top();
		id_stack.pop();

		assert(nextId == 0);
		assert(formulas[0].size() == 1);
		f->formula = formulas[0][0];

#line  677 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 249 "Frontend/Parser/formula_unparse.k"
		const tFormula f = this/**/;
#line 249 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 250 "Frontend/Parser/formula_unparse.k"

		f -> type = x -> type; 
		f -> cannotcompute = x -> cannotcompute || 
		(! x -> validLTLFormula) || (! x -> validCTLStateFormula);

#line  695 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 193 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 150 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 150 "Frontend/Parser/formula_unparse.k"
		x->fs = fs;
#line  715 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 150 "Frontend/Parser/formula_unparse.k"
		fs = x->fs;
#line  719 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 85 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  733 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  746 "ast-system-unpk.cc"
void
impl_tStatePredicate_DisjunctionList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case visible_enum: {
	    visible_class& kc_current_view=static_cast<visible_class&>(kc_current_view_base);
	    {
#line 1998 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
		kc::unparse(l, kc_printer, kc_current_view);
#line 1998 "Frontend/Parser/formula_unparse.k"
		containsNext = l -> containsNext;
#line  759 "ast-system-unpk.cc"
	    }
	    break;
	}
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    {
#line 816 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
#line 816 "Frontend/Parser/formula_unparse.k"

		id_stack.push(nextId++);

#line  772 "ast-system-unpk.cc"
		kc::unparse(l, kc_printer, kc_current_view);
#line 820 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = id_stack.top();
		id_stack.pop();

		StatePredicate *f = new DisjunctionStatePredicate(l->length());

		for (int i = 0; i < l->length(); ++i)
		{
		    assert(formulas[myId][i]);
		    ((DisjunctionStatePredicate*)f)->addSub(i, formulas[myId][i]);
		}

		formulas[id_stack.top()].push_back(f);

#line  790 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 227 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 182 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
#line 182 "Frontend/Parser/formula_unparse.k"
		l->fs=fs;
#line  810 "ast-system-unpk.cc"
		kc::unparse(l, kc_printer, kc_current_view);
#line 182 "Frontend/Parser/formula_unparse.k"
		fs=l->fs;fs->tdisj++;
#line  814 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 119 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(l, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  830 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  843 "ast-system-unpk.cc"
void
impl_tStatePredicate_ConjunctionList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case visible_enum: {
	    visible_class& kc_current_view=static_cast<visible_class&>(kc_current_view_base);
	    {
#line 1994 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
		kc::unparse(l, kc_printer, kc_current_view);
#line 1994 "Frontend/Parser/formula_unparse.k"
		containsNext = l -> containsNext;
#line  856 "ast-system-unpk.cc"
	    }
	    break;
	}
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    {
#line 777 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
#line 777 "Frontend/Parser/formula_unparse.k"

		id_stack.push(nextId++);

#line  869 "ast-system-unpk.cc"
		kc::unparse(l, kc_printer, kc_current_view);
#line 781 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = id_stack.top();
		id_stack.pop();

		StatePredicate *f = new ConjunctionStatePredicate(l->length());

		for (int i = 0; i < l->length(); ++i)
		{
		    assert(formulas[myId][i]);
		    ((ConjunctionStatePredicate*)f)->addSub(i, formulas[myId][i]);
		}

		formulas[id_stack.top()].push_back(f);

#line  887 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 223 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 178 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
#line 178 "Frontend/Parser/formula_unparse.k"
		l->fs=fs;
#line  907 "ast-system-unpk.cc"
		kc::unparse(l, kc_printer, kc_current_view);
#line 178 "Frontend/Parser/formula_unparse.k"
		fs=l->fs;fs->tconj++;
#line  911 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 115 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(l, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  927 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  940 "ast-system-unpk.cc"
void
impl_tStatePredicate_EX::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case visible_enum: {
	    visible_class& kc_current_view=static_cast<visible_class&>(kc_current_view_base);
	    {
#line 1990 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 1990 "Frontend/Parser/formula_unparse.k"
		containsNext = true;
#line  953 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1508 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1511 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  966 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    {
#line 1453 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1456 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  979 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ctl_enum: {
	    ctl_class& kc_current_view=static_cast<ctl_class&>(kc_current_view_base);
	    {
#line 1155 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 1155 "Frontend/Parser/formula_unparse.k"

		ctl_id_stack.push(ctl_nextId++);

#line  992 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 1159 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = ctl_id_stack.top();
		ctl_id_stack.pop();

		assert(ctl_formulas[myId].size() == 1);
		EXFormula* exf = new EXFormula(ctl_formulas[myId][0]);

		ctl_formulas[ctl_id_stack.top()].push_back(exf);

#line  1005 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 668 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 668 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 669 "Frontend/Parser/formula_unparse.k"

		f->containsTemporal = true;
		f->validCTLStateFormula = x->validCTLStateFormula;
		f->validCTLPathFormula = false;
		f->validLTLFormula = false;
		f->cannotcompute = (x->cannotcompute || ! x->validCTLStateFormula);
		if(!f->cannotcompute)
		{
		    f->type = FORMULA_CTL;
		} 

#line  1029 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 219 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 174 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 174 "Frontend/Parser/formula_unparse.k"
		x->fs=fs;
#line  1049 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 174 "Frontend/Parser/formula_unparse.k"
		fs=x->fs;fs->E++;fs->X++;
#line  1053 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 111 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("EX("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  1069 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  1082 "ast-system-unpk.cc"
void
impl_tStatePredicate_AX::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case visible_enum: {
	    visible_class& kc_current_view=static_cast<visible_class&>(kc_current_view_base);
	    {
#line 1988 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 1988 "Frontend/Parser/formula_unparse.k"

		containsNext = true;
#line  1096 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1507 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1511 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  1109 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    {
#line 1452 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1456 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  1122 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ctl_enum: {
	    ctl_class& kc_current_view=static_cast<ctl_class&>(kc_current_view_base);
	    {
#line 1121 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 1121 "Frontend/Parser/formula_unparse.k"

		ctl_id_stack.push(ctl_nextId++);

#line  1135 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 1125 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = ctl_id_stack.top();
		ctl_id_stack.pop();

		assert(ctl_formulas[myId].size() == 1);
		AXFormula* axf = new AXFormula(ctl_formulas[myId][0]);

		ctl_formulas[ctl_id_stack.top()].push_back(axf);

#line  1148 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 681 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 681 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 682 "Frontend/Parser/formula_unparse.k"

		f->containsTemporal = true;
		f->validCTLStateFormula = x->validCTLStateFormula;
		f->validCTLPathFormula = false;
		f->validLTLFormula = false;
		f->cannotcompute = (x->cannotcompute || ! x->validCTLStateFormula);
		if(!f->cannotcompute)
		{
		    if(x->validLTLFormula)
		    {
			f->type = FORMULA_BOTH;
		    }
		    else
		    { 
			f->type = FORMULA_CTL;
		    }
		}  
		if (f -> cannotcompute && x -> validLTLFormula)
		{
		    f->type = FORMULA_LTL;
		}

#line  1183 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 218 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 173 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 173 "Frontend/Parser/formula_unparse.k"
		x->fs=fs;
#line  1203 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 173 "Frontend/Parser/formula_unparse.k"
		fs=x->fs;fs->A++;fs->X++;
#line  1207 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 110 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("AX("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  1223 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  1236 "ast-system-unpk.cc"
void
impl_tStatePredicate_EG::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case visible_enum: {
	    visible_class& kc_current_view=static_cast<visible_class&>(kc_current_view_base);
	    {
#line 1992 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 1992 "Frontend/Parser/formula_unparse.k"
		containsNext = x -> containsNext;
#line  1249 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1510 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1511 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  1262 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    {
#line 1455 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1456 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  1275 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 668 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 668 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 669 "Frontend/Parser/formula_unparse.k"

		f->containsTemporal = true;
		f->validCTLStateFormula = x->validCTLStateFormula;
		f->validCTLPathFormula = false;
		f->validLTLFormula = false;
		f->cannotcompute = (x->cannotcompute || ! x->validCTLStateFormula);
		if(!f->cannotcompute)
		{
		    f->type = FORMULA_CTL;
		} 

#line  1299 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 221 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 176 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 176 "Frontend/Parser/formula_unparse.k"
		x->fs=fs;
#line  1319 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 176 "Frontend/Parser/formula_unparse.k"
		fs=x->fs;fs->E++;fs->G++;
#line  1323 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 113 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("EG("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  1339 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  1352 "ast-system-unpk.cc"
void
impl_tStatePredicate_AG::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case visible_enum: {
	    visible_class& kc_current_view=static_cast<visible_class&>(kc_current_view_base);
	    {
#line 1987 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 1987 "Frontend/Parser/formula_unparse.k"
		containsNext = x -> containsNext;
#line  1365 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1506 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1511 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  1378 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    {
#line 1451 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1456 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  1391 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 681 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 681 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 682 "Frontend/Parser/formula_unparse.k"

		f->containsTemporal = true;
		f->validCTLStateFormula = x->validCTLStateFormula;
		f->validCTLPathFormula = false;
		f->validLTLFormula = false;
		f->cannotcompute = (x->cannotcompute || ! x->validCTLStateFormula);
		if(!f->cannotcompute)
		{
		    if(x->validLTLFormula)
		    {
			f->type = FORMULA_BOTH;
		    }
		    else
		    { 
			f->type = FORMULA_CTL;
		    }
		}  
		if (f -> cannotcompute && x -> validLTLFormula)
		{
		    f->type = FORMULA_LTL;
		}

#line  1426 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 217 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 172 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 172 "Frontend/Parser/formula_unparse.k"
		x->fs=fs;
#line  1446 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 172 "Frontend/Parser/formula_unparse.k"
		fs=x->fs;fs->A++;fs->G++;
#line  1450 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 109 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("AG("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  1466 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  1479 "ast-system-unpk.cc"
void
impl_tStatePredicate_EF::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case visible_enum: {
	    visible_class& kc_current_view=static_cast<visible_class&>(kc_current_view_base);
	    {
#line 1991 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 1991 "Frontend/Parser/formula_unparse.k"
		containsNext = x -> containsNext;
#line  1492 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1509 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1511 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  1505 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    {
#line 1454 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1456 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  1518 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 668 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 668 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 669 "Frontend/Parser/formula_unparse.k"

		f->containsTemporal = true;
		f->validCTLStateFormula = x->validCTLStateFormula;
		f->validCTLPathFormula = false;
		f->validLTLFormula = false;
		f->cannotcompute = (x->cannotcompute || ! x->validCTLStateFormula);
		if(!f->cannotcompute)
		{
		    f->type = FORMULA_CTL;
		} 

#line  1542 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 220 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 175 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 175 "Frontend/Parser/formula_unparse.k"
		x->fs=fs;
#line  1562 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 175 "Frontend/Parser/formula_unparse.k"
		fs=x->fs;fs->E++;fs->F++;
#line  1566 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 112 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("EF("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  1582 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  1595 "ast-system-unpk.cc"
void
impl_tStatePredicate_AF::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case visible_enum: {
	    visible_class& kc_current_view=static_cast<visible_class&>(kc_current_view_base);
	    {
#line 1986 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 1986 "Frontend/Parser/formula_unparse.k"
		containsNext = x -> containsNext;
#line  1608 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1505 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1511 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  1621 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    {
#line 1450 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1456 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  1634 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 681 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 681 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 682 "Frontend/Parser/formula_unparse.k"

		f->containsTemporal = true;
		f->validCTLStateFormula = x->validCTLStateFormula;
		f->validCTLPathFormula = false;
		f->validLTLFormula = false;
		f->cannotcompute = (x->cannotcompute || ! x->validCTLStateFormula);
		if(!f->cannotcompute)
		{
		    if(x->validLTLFormula)
		    {
			f->type = FORMULA_BOTH;
		    }
		    else
		    { 
			f->type = FORMULA_CTL;
		    }
		}  
		if (f -> cannotcompute && x -> validLTLFormula)
		{
		    f->type = FORMULA_LTL;
		}

#line  1669 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 216 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 171 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 171 "Frontend/Parser/formula_unparse.k"
		x->fs=fs;
#line  1689 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 171 "Frontend/Parser/formula_unparse.k"
		fs=x->fs;fs->A++;fs->F++;
#line  1693 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 108 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("AF("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  1709 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  1722 "ast-system-unpk.cc"
void
impl_tStatePredicate_ER::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case visible_enum: {
	    visible_class& kc_current_view=static_cast<visible_class&>(kc_current_view_base);
	    {
#line 1984 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 1984 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 1984 "Frontend/Parser/formula_unparse.k"
		containsNext = x -> containsNext || y -> containsNext;
#line  1738 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1503 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1511 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  1751 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    {
#line 1448 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1456 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  1764 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 631 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 631 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 631 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 632 "Frontend/Parser/formula_unparse.k"

		f->containsTemporal = true;
		f->validCTLStateFormula = x->validCTLStateFormula && y->validCTLStateFormula;
		f->validCTLPathFormula = false;
		f->validLTLFormula = false;
		f->cannotcompute = (x->cannotcompute || y -> cannotcompute || ! x->validCTLStateFormula || ! y->validCTLStateFormula);
		if(!f->cannotcompute)
		{
		    f->type = FORMULA_CTL;
		} 

#line  1791 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 214 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 214 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 169 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 169 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
#line 169 "Frontend/Parser/formula_unparse.k"
		x->fs=fs;
#line  1816 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 169 "Frontend/Parser/formula_unparse.k"
		y->fs=x->fs;
#line  1820 "ast-system-unpk.cc"
		kc::unparse(y, kc_printer, kc_current_view);
#line 169 "Frontend/Parser/formula_unparse.k"
		fs=y->fs;fs->E++;fs->R++;
#line  1824 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 106 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 106 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("E("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" R "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  1844 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  1857 "ast-system-unpk.cc"
void
impl_tStatePredicate_AR::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case visible_enum: {
	    visible_class& kc_current_view=static_cast<visible_class&>(kc_current_view_base);
	    {
#line 1983 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 1983 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 1983 "Frontend/Parser/formula_unparse.k"
		containsNext = x -> containsNext || y -> containsNext;
#line  1873 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1502 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1511 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  1886 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    {
#line 1447 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1456 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  1899 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 644 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 644 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 644 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 645 "Frontend/Parser/formula_unparse.k"

		f->containsTemporal = true;
		f->validCTLStateFormula = x->validCTLStateFormula && y->validCTLStateFormula;
		f->validCTLPathFormula = false;
		f->validLTLFormula = false;
		f->cannotcompute = (x->cannotcompute || y -> cannotcompute || ! x->validCTLStateFormula || ! y->validCTLStateFormula);
		if(!f->cannotcompute)
		{
		    if(x -> validLTLFormula && y -> validLTLFormula)
		    {
			f->type = FORMULA_BOTH;
		    }
		    else
		    {
			f->type = FORMULA_CTL;
		    }
		}  
		if (f -> cannotcompute && x -> validLTLFormula && y -> validLTLFormula)
		{
		    f->type = FORMULA_LTL;
		}

#line  1937 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 213 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 213 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 168 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 168 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
#line 168 "Frontend/Parser/formula_unparse.k"
		x->fs=fs;
#line  1962 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 168 "Frontend/Parser/formula_unparse.k"
		y->fs=x->fs;
#line  1966 "ast-system-unpk.cc"
		kc::unparse(y, kc_printer, kc_current_view);
#line 168 "Frontend/Parser/formula_unparse.k"
		fs=y->fs;fs->A++;fs->R++;
#line  1970 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 105 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 105 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("A("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" R "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  1990 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  2003 "ast-system-unpk.cc"
void
impl_tStatePredicate_EU::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case visible_enum: {
	    visible_class& kc_current_view=static_cast<visible_class&>(kc_current_view_base);
	    {
#line 1982 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 1982 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 1982 "Frontend/Parser/formula_unparse.k"
		containsNext = x -> containsNext || y -> containsNext;
#line  2019 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1501 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1511 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  2032 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    {
#line 1446 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1456 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  2045 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ctl_enum: {
	    ctl_class& kc_current_view=static_cast<ctl_class&>(kc_current_view_base);
	    {
#line 1170 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this->tStatePredicate_1;
#line 1170 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate b = this->tStatePredicate_2;
#line 1170 "Frontend/Parser/formula_unparse.k"

		ctl_id_stack.push(ctl_nextId++);
		const size_t myDFSId = ctl_dfs_id++;
		const size_t myCacheId = ctl_result_cache_id++;

#line  2062 "ast-system-unpk.cc"
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
#line 1176 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = ctl_id_stack.top();
		ctl_id_stack.pop();

		assert(ctl_formulas[myId].size() == 2);
		EUFormula* euf = new EUFormula(ctl_formulas[myId][0], ctl_formulas[myId][1]);
		euf->index = 2 * myCacheId;
		euf->dfsindex = myDFSId * SIZEOF_STATENUMBER_T;

		ctl_formulas[ctl_id_stack.top()].push_back(euf);

#line  2078 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 631 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 631 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 631 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 632 "Frontend/Parser/formula_unparse.k"

		f->containsTemporal = true;
		f->validCTLStateFormula = x->validCTLStateFormula && y->validCTLStateFormula;
		f->validCTLPathFormula = false;
		f->validLTLFormula = false;
		f->cannotcompute = (x->cannotcompute || y -> cannotcompute || ! x->validCTLStateFormula || ! y->validCTLStateFormula);
		if(!f->cannotcompute)
		{
		    f->type = FORMULA_CTL;
		} 

#line  2105 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 212 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 212 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 167 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 167 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
#line 167 "Frontend/Parser/formula_unparse.k"
		x->fs=fs;
#line  2130 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 167 "Frontend/Parser/formula_unparse.k"
		y->fs=x->fs;
#line  2134 "ast-system-unpk.cc"
		kc::unparse(y, kc_printer, kc_current_view);
#line 167 "Frontend/Parser/formula_unparse.k"
		fs=y->fs;fs->E++;fs->U++;
#line  2138 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 104 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 104 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("E("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" U "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  2158 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  2171 "ast-system-unpk.cc"
void
impl_tStatePredicate_AU::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case visible_enum: {
	    visible_class& kc_current_view=static_cast<visible_class&>(kc_current_view_base);
	    {
#line 1985 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 1985 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 1985 "Frontend/Parser/formula_unparse.k"
		containsNext = x -> containsNext || y -> containsNext; 
#line  2187 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1504 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1511 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  2200 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    {
#line 1449 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1456 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  2213 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ctl_enum: {
	    ctl_class& kc_current_view=static_cast<ctl_class&>(kc_current_view_base);
	    {
#line 1136 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this->tStatePredicate_1;
#line 1136 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate b = this->tStatePredicate_2;
#line 1136 "Frontend/Parser/formula_unparse.k"

		ctl_id_stack.push(ctl_nextId++);
		const size_t myDFSId = ctl_dfs_id++;
		const size_t myCacheId = ctl_result_cache_id++;

#line  2230 "ast-system-unpk.cc"
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
#line 1142 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = ctl_id_stack.top();
		ctl_id_stack.pop();

		assert(ctl_formulas[myId].size() == 2);
		AUFormula* auf = new AUFormula(ctl_formulas[myId][0], ctl_formulas[myId][1]);
		auf->index = 2 * myCacheId;
		auf->dfsindex = myDFSId * SIZEOF_STATENUMBER_T;

		ctl_formulas[ctl_id_stack.top()].push_back(auf);

#line  2246 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 644 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 644 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 644 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 645 "Frontend/Parser/formula_unparse.k"

		f->containsTemporal = true;
		f->validCTLStateFormula = x->validCTLStateFormula && y->validCTLStateFormula;
		f->validCTLPathFormula = false;
		f->validLTLFormula = false;
		f->cannotcompute = (x->cannotcompute || y -> cannotcompute || ! x->validCTLStateFormula || ! y->validCTLStateFormula);
		if(!f->cannotcompute)
		{
		    if(x -> validLTLFormula && y -> validLTLFormula)
		    {
			f->type = FORMULA_BOTH;
		    }
		    else
		    {
			f->type = FORMULA_CTL;
		    }
		}  
		if (f -> cannotcompute && x -> validLTLFormula && y -> validLTLFormula)
		{
		    f->type = FORMULA_LTL;
		}

#line  2284 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 215 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 215 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 170 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 170 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
#line 170 "Frontend/Parser/formula_unparse.k"
		x->fs=fs;
#line  2309 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 170 "Frontend/Parser/formula_unparse.k"
		y->fs=x->fs;
#line  2313 "ast-system-unpk.cc"
		kc::unparse(y, kc_printer, kc_current_view);
#line 170 "Frontend/Parser/formula_unparse.k"
		fs=y->fs;fs->A++;fs->U++;
#line  2317 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 107 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 107 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("A("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" U "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  2337 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  2350 "ast-system-unpk.cc"
void
impl_tStatePredicate_Release::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case visible_enum: {
	    visible_class& kc_current_view=static_cast<visible_class&>(kc_current_view_base);
	    {
#line 1981 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 1981 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		kc::unparse(phi, kc_printer, kc_current_view);
		kc::unparse(psi, kc_printer, kc_current_view);
#line 1981 "Frontend/Parser/formula_unparse.k"
		containsNext = phi->containsNext || psi->containsNext;
#line  2366 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1500 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1511 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  2379 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    {
#line 1445 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1456 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  2392 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ltl_enum: {
	    ltl_class& kc_current_view=static_cast<ltl_class&>(kc_current_view_base);
	    {
#line 1362 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 1362 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		kc::unparse(phi, kc_printer, kc_current_view);
		kc::unparse(psi, kc_printer, kc_current_view);
#line 1365 "Frontend/Parser/formula_unparse.k"

		LTLTree_p a = ltlstack.back();
		ltlstack.pop_back();
		LTLTree_p b = ltlstack.back();
		ltlstack.pop_back();
		ltlstack.push_back(bin_simpler(tl_nn(V_OPER, b, a)));

#line  2413 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 616 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 616 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 616 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 617 "Frontend/Parser/formula_unparse.k"

		f->cannotcompute = ( x -> cannotcompute || y -> cannotcompute || !((x->validLTLFormula && y -> validLTLFormula)||(x->validCTLStateFormula && y->validCTLStateFormula)));
		f->containsTemporal = true;
		f->validCTLStateFormula = false;
		f->validCTLPathFormula = (x->validCTLStateFormula && y->validCTLStateFormula);
		f->validLTLFormula = (x->validLTLFormula && y->validLTLFormula);
		if((not f->cannotcompute) && f->validLTLFormula)
		{
		    f->type = FORMULA_LTL;
		}

#line  2440 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 211 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 211 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		kc::unparse(phi, kc_printer, kc_current_view);
		kc::unparse(psi, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 166 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 166 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
#line 166 "Frontend/Parser/formula_unparse.k"
		phi->fs=fs;
#line  2465 "ast-system-unpk.cc"
		kc::unparse(phi, kc_printer, kc_current_view);
#line 166 "Frontend/Parser/formula_unparse.k"
		psi->fs=phi->fs;
#line  2469 "ast-system-unpk.cc"
		kc::unparse(psi, kc_printer, kc_current_view);
#line 166 "Frontend/Parser/formula_unparse.k"
		fs=psi->fs;fs->R++;
#line  2473 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 103 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 103 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(phi, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" R "), kc_current_view); }
		kc::unparse(psi, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  2493 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  2506 "ast-system-unpk.cc"
void
impl_tStatePredicate_Until::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case visible_enum: {
	    visible_class& kc_current_view=static_cast<visible_class&>(kc_current_view_base);
	    {
#line 1980 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 1980 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		kc::unparse(phi, kc_printer, kc_current_view);
		kc::unparse(psi, kc_printer, kc_current_view);
#line 1980 "Frontend/Parser/formula_unparse.k"
		containsNext = phi->containsNext || psi -> containsNext;
#line  2522 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1499 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1511 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  2535 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    {
#line 1444 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1456 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  2548 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ltl_enum: {
	    ltl_class& kc_current_view=static_cast<ltl_class&>(kc_current_view_base);
	    {
#line 1350 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 1350 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		kc::unparse(phi, kc_printer, kc_current_view);
		kc::unparse(psi, kc_printer, kc_current_view);
#line 1353 "Frontend/Parser/formula_unparse.k"

		LTLTree_p a = ltlstack.back();
		ltlstack.pop_back();
		LTLTree_p b = ltlstack.back();
		ltlstack.pop_back();
		ltlstack.push_back(bin_simpler(tl_nn(U_OPER, b, a)));

#line  2569 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 616 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 616 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 616 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 617 "Frontend/Parser/formula_unparse.k"

		f->cannotcompute = ( x -> cannotcompute || y -> cannotcompute || !((x->validLTLFormula && y -> validLTLFormula)||(x->validCTLStateFormula && y->validCTLStateFormula)));
		f->containsTemporal = true;
		f->validCTLStateFormula = false;
		f->validCTLPathFormula = (x->validCTLStateFormula && y->validCTLStateFormula);
		f->validLTLFormula = (x->validLTLFormula && y->validLTLFormula);
		if((not f->cannotcompute) && f->validLTLFormula)
		{
		    f->type = FORMULA_LTL;
		}

#line  2596 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 210 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 210 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		kc::unparse(phi, kc_printer, kc_current_view);
		kc::unparse(psi, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 165 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 165 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
#line 165 "Frontend/Parser/formula_unparse.k"
		phi->fs=fs;
#line  2621 "ast-system-unpk.cc"
		kc::unparse(phi, kc_printer, kc_current_view);
#line 165 "Frontend/Parser/formula_unparse.k"
		psi->fs=phi->fs;
#line  2625 "ast-system-unpk.cc"
		kc::unparse(psi, kc_printer, kc_current_view);
#line 165 "Frontend/Parser/formula_unparse.k"
		fs=psi->fs;fs->U++;
#line  2629 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 102 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 102 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(phi, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" U "), kc_current_view); }
		kc::unparse(psi, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  2649 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  2662 "ast-system-unpk.cc"
void
impl_tStatePredicate_NextState::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case visible_enum: {
	    visible_class& kc_current_view=static_cast<visible_class&>(kc_current_view_base);
	    {
#line 1979 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 1979 "Frontend/Parser/formula_unparse.k"
		containsNext = true;
#line  2675 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1498 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1511 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  2688 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    {
#line 1443 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1456 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  2701 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ltl_enum: {
	    ltl_class& kc_current_view=static_cast<ltl_class&>(kc_current_view_base);
	    {
#line 1342 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 1344 "Frontend/Parser/formula_unparse.k"

		LTLTree_p a = ltlstack.back();
		ltlstack.pop_back();
		ltlstack.push_back(bin_simpler(tl_nn(NEXT, a, NULL)));

#line  2717 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 603 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 603 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 604 "Frontend/Parser/formula_unparse.k"

		f->cannotcompute = (x -> cannotcompute || !(x->validLTLFormula || x->validCTLStateFormula));
		if((not f->cannotcompute)&& x->validLTLFormula)
		{
		    f->type = FORMULA_LTL;
		}
		f->containsTemporal = true;
		f->validCTLStateFormula = false;
		f->validCTLPathFormula = x->validCTLStateFormula;
		f->validLTLFormula = x->validLTLFormula;

#line  2741 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 209 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 164 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 164 "Frontend/Parser/formula_unparse.k"
		x->fs=fs;
#line  2761 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 164 "Frontend/Parser/formula_unparse.k"
		fs=x->fs;fs->X++;
#line  2765 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 101 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("X ("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  2781 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  2794 "ast-system-unpk.cc"
void
impl_tStatePredicate_Eventually::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case visible_enum: {
	    visible_class& kc_current_view=static_cast<visible_class&>(kc_current_view_base);
	    {
#line 1978 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 1978 "Frontend/Parser/formula_unparse.k"
		containsNext = x -> containsNext;
#line  2807 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1497 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1511 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  2820 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    {
#line 1442 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1456 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  2833 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ltl_enum: {
	    ltl_class& kc_current_view=static_cast<ltl_class&>(kc_current_view_base);
	    {
#line 1326 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 1328 "Frontend/Parser/formula_unparse.k"

		LTLTree_p a = ltlstack.back();
		ltlstack.pop_back();
		ltlstack.push_back(bin_simpler(tl_nn(U_OPER, tl_nn(TRUE, NULL, NULL), a)));

#line  2849 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    if ((this->tStatePredicate_1->prod_sel() == sel_Always)) {
#line 469 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 469 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate g = this->tStatePredicate_1;
#line 469 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Always*>(this->tStatePredicate_1)->tStatePredicate_1;
		kc::unparse(y, kc_printer, kc_current_view);
#line 470 "Frontend/Parser/formula_unparse.k"

		if(not y->containsTemporal)
		{
		    f -> type = FORMULA_STABILIZATION;
		    f -> cannotcompute = false;
		    f -> validLTLFormula = true;
		}
		else
		{
		    f -> cannotcompute = (y->cannotcompute || ! y -> validLTLFormula);
		    f -> validLTLFormula = y -> validLTLFormula;
		    if(!f -> cannotcompute)
		    {
			f -> type = FORMULA_LTL; 
		    }
		}
		f -> validCTLPathFormula = false;
		f -> validCTLStateFormula = false;
		f -> containsTemporal = true;
		g -> containsTemporal = true;

#line  2885 "ast-system-unpk.cc"
	    } else
	    {
#line 492 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 492 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_1;
		kc::unparse(y, kc_printer, kc_current_view);
#line 493 "Frontend/Parser/formula_unparse.k"

		if(not y->containsTemporal)
		{
		    f -> type = FORMULA_EVENTUALLY;
		    f -> cannotcompute = false;
		    f -> validLTLFormula = true;
		}
		else
		{
		    f -> cannotcompute = (y->cannotcompute || ((!y -> validLTLFormula) && !(y -> validCTLStateFormula)));
		    f -> validLTLFormula = y -> validLTLFormula;
		    if(!f -> cannotcompute)
		    {
			f -> type = FORMULA_LTL; 
		    }
		}
		f -> validCTLPathFormula = y -> validCTLStateFormula;
		f -> validCTLStateFormula = false;
		f -> containsTemporal = true;

#line  2914 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 208 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 163 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 163 "Frontend/Parser/formula_unparse.k"
		x->fs=fs;
#line  2934 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 163 "Frontend/Parser/formula_unparse.k"
		fs=x->fs;fs->F++;
#line  2938 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 100 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("F ("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  2954 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  2967 "ast-system-unpk.cc"
void
impl_tStatePredicate_Always::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case visible_enum: {
	    visible_class& kc_current_view=static_cast<visible_class&>(kc_current_view_base);
	    {
#line 1977 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 1977 "Frontend/Parser/formula_unparse.k"
		containsNext = x -> containsNext;
#line  2980 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1496 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1511 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  2993 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    {
#line 1441 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1456 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  3006 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ltl_enum: {
	    ltl_class& kc_current_view=static_cast<ltl_class&>(kc_current_view_base);
	    {
#line 1334 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 1336 "Frontend/Parser/formula_unparse.k"

		LTLTree_p a = ltlstack.back();
		ltlstack.pop_back();
		ltlstack.push_back(bin_simpler(tl_nn(V_OPER, tl_nn(FALSE, NULL, NULL), a)));

#line  3022 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    if ((this->tStatePredicate_1->prod_sel() == sel_Eventually)) {
#line 446 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 446 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate g = this->tStatePredicate_1;
#line 446 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(this->tStatePredicate_1)->tStatePredicate_1;
		kc::unparse(y, kc_printer, kc_current_view);
#line 447 "Frontend/Parser/formula_unparse.k"

		if(not y->containsTemporal)
		{
		    f -> type = FORMULA_FAIRNESS;
		    f -> cannotcompute = false;
		    f -> validLTLFormula = true;
		}
		else
		{
		    f -> cannotcompute = (y->cannotcompute || ! y -> validLTLFormula);
		    f -> validLTLFormula = y -> validLTLFormula;
		    if(!f -> cannotcompute)
		    {
			f -> type = FORMULA_LTL; 
		    }
		}
		f -> validCTLPathFormula = false;
		f -> validCTLStateFormula = false;
		f -> containsTemporal = true;
		g -> containsTemporal = true;

#line  3058 "ast-system-unpk.cc"
	    } else
	    {
#line 603 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 603 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 604 "Frontend/Parser/formula_unparse.k"

		f->cannotcompute = (x -> cannotcompute || !(x->validLTLFormula || x->validCTLStateFormula));
		if((not f->cannotcompute)&& x->validLTLFormula)
		{
		    f->type = FORMULA_LTL;
		}
		f->containsTemporal = true;
		f->validCTLStateFormula = false;
		f->validCTLPathFormula = x->validCTLStateFormula;
		f->validLTLFormula = x->validLTLFormula;

#line  3078 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 207 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 162 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 162 "Frontend/Parser/formula_unparse.k"
		x->fs=fs;
#line  3098 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 162 "Frontend/Parser/formula_unparse.k"
		fs=x->fs;fs->G++;
#line  3102 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 99 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("G ("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  3118 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  3131 "ast-system-unpk.cc"
void
impl_tStatePredicate_ExPath::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case visible_enum: {
	    visible_class& kc_current_view=static_cast<visible_class&>(kc_current_view_base);
	    {
#line 1976 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 1976 "Frontend/Parser/formula_unparse.k"
		containsNext = x -> containsNext;
#line  3144 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1495 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1511 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  3157 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    {
#line 1440 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1456 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  3170 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    if ((this->tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(this->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually)) {
#line 307 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 307 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate g = this->tStatePredicate_1;
#line 307 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = phylum_cast<const impl_tStatePredicate_Eventually*>(this->tStatePredicate_1)->tStatePredicate_1;
#line 307 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate i = phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 307 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate j = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 307 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate k = phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 307 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
		kc::unparse(y, kc_printer, kc_current_view);
#line 308 "Frontend/Parser/formula_unparse.k"

		if(not y->containsTemporal)
		{
		    f -> type = FORMULA_EGAGEF;
		    f -> cannotcompute = false;
		    f -> validCTLStateFormula = true;
		}
		else
		{
		    f -> cannotcompute = (y->cannotcompute || !y -> validCTLStateFormula);
		    f -> validCTLStateFormula = y -> validCTLStateFormula;
		    if(!f -> cannotcompute)
		    {
			f -> type = FORMULA_CTL; 
		    }
		}
		f -> validCTLPathFormula = false;
		f -> validLTLFormula = false;
		f -> containsTemporal = true;
		g -> containsTemporal = true;
		h -> containsTemporal = true;
		i -> containsTemporal = true;
		j -> containsTemporal = true;
		k -> containsTemporal = true;

#line  3218 "ast-system-unpk.cc"
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(this->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Eventually*>(this->tStatePredicate_1)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) {
#line 256 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 256 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate g = this->tStatePredicate_1;
#line 256 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = phylum_cast<const impl_tStatePredicate_Eventually*>(this->tStatePredicate_1)->tStatePredicate_1;
#line 257 "Frontend/Parser/formula_unparse.k"

		f -> type = FORMULA_DEADLOCK;
		f -> cannotcompute = false;
		f -> validCTLStateFormula = true;
		f -> validCTLPathFormula = false;
		f -> validLTLFormula = false;
		f -> containsTemporal = true;
		g -> containsTemporal = true;
		h -> containsTemporal = false;

#line  3238 "ast-system-unpk.cc"
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(this->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always)) {
#line 334 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 334 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate g = this->tStatePredicate_1;
#line 334 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = phylum_cast<const impl_tStatePredicate_Eventually*>(this->tStatePredicate_1)->tStatePredicate_1;
#line 334 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate i = phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 334 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
		kc::unparse(y, kc_printer, kc_current_view);
#line 335 "Frontend/Parser/formula_unparse.k"

		if(not y->containsTemporal)
		{
		    f -> type = FORMULA_EFAG;
		    f -> cannotcompute = false;
		    f -> validCTLStateFormula = true;
		}
		else
		{
		    f -> cannotcompute = (y->cannotcompute || ! y -> validCTLStateFormula);
		    f -> validCTLStateFormula = y -> validCTLStateFormula;
		    if(!f -> cannotcompute)
		    {
			f -> type = FORMULA_CTL; 
		    }
		}
		f -> validCTLPathFormula = false;
		f -> validLTLFormula = false;
		f -> containsTemporal = true;
		g -> containsTemporal = true;
		h -> containsTemporal = true;
		i -> containsTemporal = true;

#line  3276 "ast-system-unpk.cc"
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_Eventually)) {
#line 384 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 384 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate g = this->tStatePredicate_1;
#line 384 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(this->tStatePredicate_1)->tStatePredicate_1;
		kc::unparse(y, kc_printer, kc_current_view);
#line 385 "Frontend/Parser/formula_unparse.k"

		if(not y->containsTemporal)
		{
		    f -> type = FORMULA_REACHABLE;
		    f -> cannotcompute = false;
		    f -> validCTLStateFormula = true;
		}
		else
		{
		    f -> cannotcompute = (y->cannotcompute || !y -> validCTLStateFormula);
		    f -> validCTLStateFormula = y -> validCTLStateFormula;
		    if(!f -> cannotcompute)
		    {
			f -> type = FORMULA_CTL; 
		    }
		}
		f -> validCTLPathFormula = false;
		f -> validLTLFormula = false;
		f -> containsTemporal = true;
		g -> containsTemporal = true;

#line  3308 "ast-system-unpk.cc"
	    } else
	    {
#line 590 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 590 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 591 "Frontend/Parser/formula_unparse.k"

		f->cannotcompute = (x -> cannotcompute || !(x->validCTLPathFormula));
		if(! f->cannotcompute)
		{
		    f->type = FORMULA_CTL;
		}
		f->containsTemporal = true;
		f->validCTLStateFormula = x->validCTLPathFormula;
		f->validCTLPathFormula = false;
		f->validLTLFormula = false;

#line  3328 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 206 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 161 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 161 "Frontend/Parser/formula_unparse.k"
		x->fs=fs;
#line  3348 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 161 "Frontend/Parser/formula_unparse.k"
		fs=x->fs;fs->E++;
#line  3352 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 98 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("E ("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  3368 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  3381 "ast-system-unpk.cc"
void
impl_tStatePredicate_AllPath::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case visible_enum: {
	    visible_class& kc_current_view=static_cast<visible_class&>(kc_current_view_base);
	    {
#line 1975 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 1975 "Frontend/Parser/formula_unparse.k"
		containsNext = x -> containsNext;
#line  3394 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1494 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1511 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  3407 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    {
#line 1439 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1456 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  3420 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    if ((this->tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(this->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always)) {
#line 280 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 280 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate g = this->tStatePredicate_1;
#line 280 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = phylum_cast<const impl_tStatePredicate_Always*>(this->tStatePredicate_1)->tStatePredicate_1;
#line 280 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate i = phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 280 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate j = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 280 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate k = phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 280 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
		kc::unparse(y, kc_printer, kc_current_view);
#line 281 "Frontend/Parser/formula_unparse.k"

		if(not y->containsTemporal)
		{
		    f -> type = FORMULA_AGEFAG;
		    f -> cannotcompute = false;
		    f -> validCTLStateFormula = true;
		}
		else
		{
		    f -> cannotcompute = (y->cannotcompute || !y -> validCTLStateFormula);
		    f -> validCTLStateFormula = y -> validCTLStateFormula;
		    if( ! f -> cannotcompute)
		    {
			f -> type = FORMULA_CTL; 
		    }
		}
		f -> validCTLPathFormula = false;
		f -> validLTLFormula = false;
		f -> containsTemporal = true;
		g -> containsTemporal = true;
		h -> containsTemporal = true;
		i -> containsTemporal = true;
		j -> containsTemporal = true;
		k -> containsTemporal = true;

#line  3468 "ast-system-unpk.cc"
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(this->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Always*>(this->tStatePredicate_1)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) {
#line 268 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 268 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate g = this->tStatePredicate_1;
#line 268 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = phylum_cast<const impl_tStatePredicate_Always*>(this->tStatePredicate_1)->tStatePredicate_1;
#line 269 "Frontend/Parser/formula_unparse.k"

		f -> type = FORMULA_NODEADLOCK;
		f -> cannotcompute = false;
		f -> validCTLStateFormula = true;
		f -> validCTLPathFormula = false;
		f -> validLTLFormula = false;
		f -> containsTemporal = true;
		g -> containsTemporal = true;
		h -> containsTemporal = false;

#line  3488 "ast-system-unpk.cc"
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(this->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually)) {
#line 359 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 359 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate g = this->tStatePredicate_1;
#line 359 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = phylum_cast<const impl_tStatePredicate_Always*>(this->tStatePredicate_1)->tStatePredicate_1;
#line 359 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate i = phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 359 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
		kc::unparse(y, kc_printer, kc_current_view);
#line 360 "Frontend/Parser/formula_unparse.k"

		if(not y->containsTemporal)
		{
		    f -> type = FORMULA_LIVENESS;
		    f -> cannotcompute = false;
		    f -> validCTLStateFormula = true;
		}
		else
		{
		    f -> cannotcompute = (y->cannotcompute || !y -> validCTLStateFormula);
		    f -> validCTLStateFormula = y -> validCTLStateFormula;
		    if(! f -> cannotcompute)
		    {
			f -> type = FORMULA_CTL; 
		    }
		}
		f -> validCTLPathFormula = false;
		f -> validLTLFormula = false;
		f -> containsTemporal = true;
		g -> containsTemporal = true;
		h -> containsTemporal = true;
		i -> containsTemporal = true;

#line  3526 "ast-system-unpk.cc"
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_Always)) {
#line 407 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 407 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate g = this->tStatePredicate_1;
#line 407 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Always*>(this->tStatePredicate_1)->tStatePredicate_1;
		kc::unparse(y, kc_printer, kc_current_view);
#line 408 "Frontend/Parser/formula_unparse.k"

		if(not y->containsTemporal)
		{
		    f -> type = FORMULA_INVARIANT;
		    f -> cannotcompute = false;
		    f -> validCTLStateFormula = true;
		    f -> validLTLFormula = y -> validLTLFormula;
		}
		else
		{   
		    f -> cannotcompute = (y->cannotcompute || !y -> validCTLStateFormula);
		    f -> validCTLStateFormula = y -> validCTLStateFormula;
		    if(! f -> cannotcompute)
		    {
			if(y->validLTLFormula)
			{
			    f->type = FORMULA_BOTH;
			}
			else
			{
			    f -> type = FORMULA_CTL; 
			}
		    }
		    else
		    {
			f -> validLTLFormula = false;
			if (y -> validLTLFormula)
			{
			    f -> type = FORMULA_LTL;
			    f -> cannotcompute = false;
			}
		    }
		}
		f -> validCTLPathFormula = false;
		f -> containsTemporal = true;
		g -> containsTemporal = true;

#line  3574 "ast-system-unpk.cc"
	    } else
	    {
#line 566 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 566 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 567 "Frontend/Parser/formula_unparse.k"

		f->cannotcompute = (x -> cannotcompute || !(x->validCTLPathFormula));
		if(! f->cannotcompute)
		{
		    if(x->validLTLFormula)
		    {
			f->type = FORMULA_BOTH;
		    }
		    else
		    {
			f->type = FORMULA_CTL;
		    }
		}
		if (f -> cannotcompute && x -> validLTLFormula)
		{
		    f->type = FORMULA_LTL;
		}
		f->containsTemporal = true;
		f->validCTLStateFormula = x->validCTLPathFormula;
		f->validCTLPathFormula = false;
		f->validLTLFormula = false;

#line  3605 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 205 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 160 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 160 "Frontend/Parser/formula_unparse.k"
		x->fs=fs;
#line  3625 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 160 "Frontend/Parser/formula_unparse.k"
		fs=x->fs;fs->A++;
#line  3629 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 97 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("A ("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  3645 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  3658 "ast-system-unpk.cc"
void
impl_tStatePredicate_Equivalence::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 204 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 204 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 96 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 96 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" <-> "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  3691 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  3704 "ast-system-unpk.cc"
void
impl_tStatePredicate_Implication::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 203 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 203 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 95 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 95 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" -> "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  3737 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  3750 "ast-system-unpk.cc"
void
impl_tStatePredicate_ExclusiveDisjunction::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 202 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 202 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 94 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 94 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" XOR "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  3783 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  3796 "ast-system-unpk.cc"
void
impl_tStatePredicate_Disjunction::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case visible_enum: {
	    visible_class& kc_current_view=static_cast<visible_class&>(kc_current_view_base);
	    {
#line 1974 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 1974 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 1974 "Frontend/Parser/formula_unparse.k"
		containsNext = x -> containsNext || y -> containsNext;
#line  3812 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    if ((KC_TRACE_PROVIDED((this/**/->type != FORMULA_INITIAL), "Frontend/Parser/formula_unparse.k", 1430, this))) {
#line 1430 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1430 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 1430 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 1431 "Frontend/Parser/formula_unparse.k"

		f->task = new DisjunctionTask(x->task,y->task);

#line  3831 "ast-system-unpk.cc"
	    } else
		if ((KC_TRACE_PROVIDED((this/**/->type == FORMULA_INITIAL), "Frontend/Parser/formula_unparse.k", 1438, this))) {
#line 1438 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1456 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  3840 "ast-system-unpk.cc"
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case ltl_enum: {
	    ltl_class& kc_current_view=static_cast<ltl_class&>(kc_current_view_base);
	    {
#line 1393 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 1393 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 1396 "Frontend/Parser/formula_unparse.k"

		LTLTree_p a = ltlstack.back();
		ltlstack.pop_back();
		LTLTree_p b = ltlstack.back();
		ltlstack.pop_back();
		ltlstack.push_back(bin_simpler(tl_nn(OR, a, b)));

#line  3862 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ctl_enum: {
	    ctl_class& kc_current_view=static_cast<ctl_class&>(kc_current_view_base);
	    if ((KC_TRACE_PROVIDED((this/**/->containsTemporal), "Frontend/Parser/formula_unparse.k", 1106, this))) {
#line 1106 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1106 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this->tStatePredicate_1;
#line 1106 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate b = this->tStatePredicate_2;
#line 1106 "Frontend/Parser/formula_unparse.k"

		ctl_id_stack.push(ctl_nextId++);

#line  3879 "ast-system-unpk.cc"
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
#line 1110 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = ctl_id_stack.top();
		ctl_id_stack.pop();

		DisjunctionFormula *df = new DisjunctionFormula(ctl_formulas[myId]);
		ctl_formulas[ctl_id_stack.top()].push_back(df);

#line  3891 "ast-system-unpk.cc"
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    {
#line 797 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this->tStatePredicate_1;
#line 797 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate b = this->tStatePredicate_2;
#line 797 "Frontend/Parser/formula_unparse.k"

		id_stack.push(nextId++);

#line  3907 "ast-system-unpk.cc"
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
#line 801 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t  myId = id_stack.top();
		id_stack.pop();

		StatePredicate *f = new DisjunctionStatePredicate(formulas[myId].size());
		for (size_t i = 0; i < formulas[myId].size(); ++i)
		{
		    assert(formulas[myId][i]);
		    ((DisjunctionStatePredicate*)f)->addSub(i, formulas[myId][i]);
		}

		formulas[id_stack.top()].push_back(f);

#line  3925 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 545 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 545 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 545 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 546 "Frontend/Parser/formula_unparse.k"

		if(not (x->containsTemporal || y->containsTemporal))
		{
		    f->type = FORMULA_INITIAL;
		}
		else
		{
		    f->type = FORMULA_BOOLEAN;
		}
		f->cannotcompute=x->cannotcompute || y -> cannotcompute;
		if(f->cannotcompute)
		{
		    f->type = FORMULA_MODELCHECKING;
		}
		f->containsTemporal = (x->containsTemporal || y->containsTemporal);
		f->validCTLStateFormula = (x->validCTLStateFormula && y->validCTLStateFormula);
		f->validCTLPathFormula = false;
		f->validLTLFormula = (x->validLTLFormula && y->validLTLFormula);

#line  3960 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 201 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 201 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 159 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 159 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
#line 159 "Frontend/Parser/formula_unparse.k"
		x->fs=fs;
#line  3985 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 159 "Frontend/Parser/formula_unparse.k"
		y->fs=x->fs;
#line  3989 "ast-system-unpk.cc"
		kc::unparse(y, kc_printer, kc_current_view);
#line 159 "Frontend/Parser/formula_unparse.k"
		fs=y->fs;fs->tdisj++;
#line  3993 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 93 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 93 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" OR "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  4013 "ast-system-unpk.cc"
	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  4027 "ast-system-unpk.cc"
void
impl_tStatePredicate_Conjunction::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case visible_enum: {
	    visible_class& kc_current_view=static_cast<visible_class&>(kc_current_view_base);
	    {
#line 1973 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 1973 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 1973 "Frontend/Parser/formula_unparse.k"
		containsNext = x -> containsNext || y -> containsNext;
#line  4043 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    if ((KC_TRACE_PROVIDED((this/**/->type != FORMULA_INITIAL), "Frontend/Parser/formula_unparse.k", 1425, this))) {
#line 1425 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1425 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 1425 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 1426 "Frontend/Parser/formula_unparse.k"

		f->task = new ConjunctionTask(x->task,y->task);

#line  4062 "ast-system-unpk.cc"
	    } else
		if ((KC_TRACE_PROVIDED((this/**/->type == FORMULA_INITIAL), "Frontend/Parser/formula_unparse.k", 1437, this))) {
#line 1437 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1456 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  4071 "ast-system-unpk.cc"
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case ltl_enum: {
	    ltl_class& kc_current_view=static_cast<ltl_class&>(kc_current_view_base);
	    {
#line 1382 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 1382 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 1385 "Frontend/Parser/formula_unparse.k"

		LTLTree_p a = ltlstack.back();
		ltlstack.pop_back();
		LTLTree_p b = ltlstack.back();
		ltlstack.pop_back();
		ltlstack.push_back(bin_simpler(tl_nn(AND, a, b)));

#line  4093 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ctl_enum: {
	    ctl_class& kc_current_view=static_cast<ctl_class&>(kc_current_view_base);
	    if ((KC_TRACE_PROVIDED((this/**/->containsTemporal), "Frontend/Parser/formula_unparse.k", 1093, this))) {
#line 1093 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1093 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this->tStatePredicate_1;
#line 1093 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate b = this->tStatePredicate_2;
#line 1093 "Frontend/Parser/formula_unparse.k"

		ctl_id_stack.push(ctl_nextId++);

#line  4110 "ast-system-unpk.cc"
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
#line 1097 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = ctl_id_stack.top();
		ctl_id_stack.pop();

		ConjunctionFormula *cf = new ConjunctionFormula(ctl_formulas[myId]);
		ctl_formulas[ctl_id_stack.top()].push_back(cf);

#line  4122 "ast-system-unpk.cc"
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    {
#line 758 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this->tStatePredicate_1;
#line 758 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate b = this->tStatePredicate_2;
#line 758 "Frontend/Parser/formula_unparse.k"

		id_stack.push(nextId++);

#line  4138 "ast-system-unpk.cc"
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
#line 762 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = id_stack.top();
		id_stack.pop();

		StatePredicate *f = new ConjunctionStatePredicate(formulas[myId].size());
		for (size_t i = 0; i < formulas[myId].size(); ++i)
		{
		    assert(formulas[myId][i]);
		    ((ConjunctionStatePredicate*)f)->addSub(i, formulas[myId][i]);
		}

		formulas[id_stack.top()].push_back(f);

#line  4156 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 545 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 545 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 545 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 546 "Frontend/Parser/formula_unparse.k"

		if(not (x->containsTemporal || y->containsTemporal))
		{
		    f->type = FORMULA_INITIAL;
		}
		else
		{
		    f->type = FORMULA_BOOLEAN;
		}
		f->cannotcompute=x->cannotcompute || y -> cannotcompute;
		if(f->cannotcompute)
		{
		    f->type = FORMULA_MODELCHECKING;
		}
		f->containsTemporal = (x->containsTemporal || y->containsTemporal);
		f->validCTLStateFormula = (x->validCTLStateFormula && y->validCTLStateFormula);
		f->validCTLPathFormula = false;
		f->validLTLFormula = (x->validLTLFormula && y->validLTLFormula);

#line  4191 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 200 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 200 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 158 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 158 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
#line 158 "Frontend/Parser/formula_unparse.k"
		x->fs=fs;
#line  4216 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 158 "Frontend/Parser/formula_unparse.k"
		y->fs=x->fs;
#line  4220 "ast-system-unpk.cc"
		kc::unparse(y, kc_printer, kc_current_view);
#line 158 "Frontend/Parser/formula_unparse.k"
		fs=y->fs;fs->tconj++;
#line  4224 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 92 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 92 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" AND "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  4244 "ast-system-unpk.cc"
	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  4258 "ast-system-unpk.cc"
void
impl_tStatePredicate_Negation::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case visible_enum: {
	    visible_class& kc_current_view=static_cast<visible_class&>(kc_current_view_base);
	    {
#line 1972 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 1972 "Frontend/Parser/formula_unparse.k"
		containsNext = x -> containsNext;
#line  4271 "ast-system-unpk.cc"
	    }
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1493 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1511 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  4284 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    {
#line 1436 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1456 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  4297 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ltl_enum: {
	    ltl_class& kc_current_view=static_cast<ltl_class&>(kc_current_view_base);
	    {
#line 1374 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 1376 "Frontend/Parser/formula_unparse.k"

		LTLTree_p a = ltlstack.back();
		ltlstack.pop_back();
		ltlstack.push_back(bin_simpler(tl_nn(NOT, a, NULL)));

#line  4313 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ctl_enum: {
	    ctl_class& kc_current_view=static_cast<ctl_class&>(kc_current_view_base);
	    {
#line 1079 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this->tStatePredicate_1;
#line 1079 "Frontend/Parser/formula_unparse.k"

		ctl_id_stack.push(ctl_nextId++);

#line  4326 "ast-system-unpk.cc"
		kc::unparse(a, kc_printer, kc_current_view);
#line 1083 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = ctl_id_stack.top();
		ctl_id_stack.pop();

		assert(ctl_formulas[myId].size() == 1);
		NotFormula *nf = new NotFormula(ctl_formulas[myId][0]);
		ctl_formulas[ctl_id_stack.top()].push_back(nf);

#line  4338 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 524 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 524 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 525 "Frontend/Parser/formula_unparse.k"

		if(not x->containsTemporal)
		{
		    f->type = FORMULA_INITIAL;
		}
		else
		{
		    f->type = FORMULA_BOOLEAN;
		}
		f->cannotcompute=x->cannotcompute;
		if(f->cannotcompute)
		{
		    f->type = FORMULA_MODELCHECKING;
		}
		f->containsTemporal = x->containsTemporal;
		f->validCTLStateFormula = x->validCTLStateFormula;
		f->validCTLPathFormula = false;
		f->validLTLFormula = x->validLTLFormula;

#line  4370 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 199 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 157 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 157 "Frontend/Parser/formula_unparse.k"
		x->fs=fs;
#line  4390 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 157 "Frontend/Parser/formula_unparse.k"
		fs=x->fs;fs->tneg++;
#line  4394 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 91 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("NOT("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  4410 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  4423 "ast-system-unpk.cc"
void
impl_tStatePredicate_AtomicProposition::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case visible_enum: {
	    visible_class& kc_current_view=static_cast<visible_class&>(kc_current_view_base);
	    if ((this->tAtomicProposition_1->prod_sel() == sel_NNegation) && (phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 1971 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1;
#line 1971 "Frontend/Parser/formula_unparse.k"
		x -> pred -> setVisible();
#line  4435 "ast-system-unpk.cc"
			} else
		if ((this->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 1970 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
#line 1970 "Frontend/Parser/formula_unparse.k"
		x -> pred -> setVisible();
#line  4442 "ast-system-unpk.cc"
			} else
		    goto kc_unparsing_default;
	    break;
	}
	case compound_enum: {
	    compound_class& kc_current_view=static_cast<compound_class&>(kc_current_view_base);
	    {
#line 1492 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1511 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  4456 "ast-system-unpk.cc"
	    }
	    break;
	}
	case toplevelboolean_enum: {
	    toplevelboolean_class& kc_current_view=static_cast<toplevelboolean_class&>(kc_current_view_base);
	    {
#line 1435 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1456 "Frontend/Parser/formula_unparse.k"

		f -> task = new LeafTask(f);

#line  4469 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ltl_enum: {
	    ltl_class& kc_current_view=static_cast<ltl_class&>(kc_current_view_base);
	    if ((this->tAtomicProposition_1->prod_sel() == sel_NNegation) && (phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 1211 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1211 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1;
#line 1212 "Frontend/Parser/formula_unparse.k"


		StatePredicate * result = x->pred -> copy(NULL);
		result = result -> negate();


		int num;
		char_p sym = produce_next_string(&num);

		predicateMap[num] = result;
		LTLTree_p newTree = tl_nn(PREDICATE, NULL, NULL);
		newTree->sym = tl_lookup(sym);
		newTree = bin_simpler(newTree);

		assert(newTree->sym);
		ltlstack.push_back(newTree);

#line  4498 "ast-system-unpk.cc"
	    } else
		if ((this->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 1231 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1231 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
#line 1232 "Frontend/Parser/formula_unparse.k"


		StatePredicate * result = x->pred->copy(NULL);


		int num;
		char_p sym = produce_next_string(&num);

		predicateMap[num] = result;
		LTLTree_p newTree = tl_nn(PREDICATE, NULL, NULL);
		newTree->sym = tl_lookup(sym);
		newTree = bin_simpler(newTree);

		assert(newTree->sym);
		ltlstack.push_back(newTree);

#line  4522 "ast-system-unpk.cc"
	    } else
		if ((this->tAtomicProposition_1->prod_sel() == sel_True)) {
#line 1250 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1251 "Frontend/Parser/formula_unparse.k"


		StatePredicate * result = new TruePredicate();


		int num;
		char_p sym = produce_next_string(&num);

		predicateMap[num] = result;
		LTLTree_p newTree = tl_nn(PREDICATE, NULL, NULL);
		newTree->sym = tl_lookup(sym);
		newTree = bin_simpler(newTree);

		assert(newTree->sym);
		ltlstack.push_back(newTree);

#line  4544 "ast-system-unpk.cc"
	    } else
		if ((this->tAtomicProposition_1->prod_sel() == sel_Deadlock)) {
#line 1269 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1270 "Frontend/Parser/formula_unparse.k"


		StatePredicate * result = new DeadlockPredicate(true);


		int num;
		char_p sym = produce_next_string(&num);

		predicateMap[num] = result;
		LTLTree_p newTree = tl_nn(PREDICATE, NULL, NULL);
		newTree->sym = tl_lookup(sym);
		newTree = bin_simpler(newTree);

		assert(newTree->sym);
		ltlstack.push_back(newTree);

#line  4566 "ast-system-unpk.cc"
	    } else
		if ((this->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) {
#line 1288 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1289 "Frontend/Parser/formula_unparse.k"


		StatePredicate * result = new DeadlockPredicate(false);


		int num;
		char_p sym = produce_next_string(&num);

		predicateMap[num] = result;
		LTLTree_p newTree = tl_nn(PREDICATE, NULL, NULL);
		newTree->sym = tl_lookup(sym);
		newTree = bin_simpler(newTree);

		assert(newTree->sym);
		ltlstack.push_back(newTree);

#line  4588 "ast-system-unpk.cc"
	    } else
		if ((this->tAtomicProposition_1->prod_sel() == sel_False)) {
#line 1307 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1308 "Frontend/Parser/formula_unparse.k"


		StatePredicate * result = new FalsePredicate();


		int num;
		char_p sym = produce_next_string(&num);

		predicateMap[num] = result;
		LTLTree_p newTree = tl_nn(PREDICATE, NULL, NULL);
		newTree->sym = tl_lookup(sym);
		newTree = bin_simpler(newTree);

		assert(newTree->sym);
		ltlstack.push_back(newTree);

#line  4610 "ast-system-unpk.cc"
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case ctl_enum: {
	    ctl_class& kc_current_view=static_cast<ctl_class&>(kc_current_view_base);
	    if ((this->tAtomicProposition_1->prod_sel() == sel_NNegation) && (phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 1030 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1030 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1;
#line 1030 "Frontend/Parser/formula_unparse.k"

		AtomicFormula* af = new AtomicFormula();
		af->inner = new StatePredicateProperty(x->pred->copy(NULL)->negate());
		ctl_formulas[ctl_id_stack.top()].push_back(af);

#line  4628 "ast-system-unpk.cc"
	    } else
		if ((this->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 1025 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1025 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
#line 1025 "Frontend/Parser/formula_unparse.k"

		AtomicFormula* af = new AtomicFormula();
		af->inner = new StatePredicateProperty(x->pred->copy(NULL));
		ctl_formulas[ctl_id_stack.top()].push_back(af);

#line  4641 "ast-system-unpk.cc"
	    } else
		if ((this->tAtomicProposition_1->prod_sel() == sel_True)) {
#line 1036 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1036 "Frontend/Parser/formula_unparse.k"

		AtomicFormula* af = new AtomicFormula();
		af->inner = new StatePredicateProperty(new TruePredicate());
		ctl_formulas[ctl_id_stack.top()].push_back(af);

#line  4652 "ast-system-unpk.cc"
	    } else
		if ((this->tAtomicProposition_1->prod_sel() == sel_False)) {
#line 1042 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1042 "Frontend/Parser/formula_unparse.k"

		AtomicFormula* af = new AtomicFormula();
		af->inner = new StatePredicateProperty(new FalsePredicate());
		ctl_formulas[ctl_id_stack.top()].push_back(af);

#line  4663 "ast-system-unpk.cc"
	    } else
		if ((this->tAtomicProposition_1->prod_sel() == sel_Deadlock)) {
#line 1048 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1048 "Frontend/Parser/formula_unparse.k"

		AtomicFormula* af = new AtomicFormula();
		af->inner = new StatePredicateProperty(new DeadlockPredicate(1));
		ctl_formulas[ctl_id_stack.top()].push_back(af);

#line  4674 "ast-system-unpk.cc"
	    } else
		if ((this->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) {
#line 1054 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 1054 "Frontend/Parser/formula_unparse.k"

		AtomicFormula* af = new AtomicFormula();
		af->inner = new StatePredicateProperty(new DeadlockPredicate(0));
		ctl_formulas[ctl_id_stack.top()].push_back(af);

#line  4685 "ast-system-unpk.cc"
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    if ((this->tAtomicProposition_1->prod_sel() == sel_NNegation) && (phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 836 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this/**/;
#line 836 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1;
#line 837 "Frontend/Parser/formula_unparse.k"

		formula = x->pred -> copy(NULL);
		formula = formula -> negate();

		formulas[id_stack.top()].push_back(formula);    

#line  4704 "ast-system-unpk.cc"
	    } else
		if ((this->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 844 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this/**/;
#line 844 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
#line 845 "Frontend/Parser/formula_unparse.k"

		formulas[id_stack.top()].push_back(x->pred->copy(NULL));    

#line  4715 "ast-system-unpk.cc"
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 514 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 515 "Frontend/Parser/formula_unparse.k"

		f->type = FORMULA_INITIAL;
		f->cannotcompute=false;
		f->containsTemporal = false;
		f->validCTLPathFormula = false;
		f->validCTLStateFormula = true;
		f->validLTLFormula = true;

#line  4734 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    if ((this->tAtomicProposition_1->prod_sel() == sel_NNegation) && (phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 198 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this/**/;
#line 198 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1;
#line 198 "Frontend/Parser/formula_unparse.k"
		x->pred=a->formula;
#line  4747 "ast-system-unpk.cc"
			} else
		if ((this->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 197 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this/**/;
#line 197 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
#line 197 "Frontend/Parser/formula_unparse.k"
		x->pred = a -> formula;
#line  4756 "ast-system-unpk.cc"
			} else
		    goto kc_unparsing_default;
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    if ((this->tAtomicProposition_1->prod_sel() == sel_NNegation) && (phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 155 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this/**/;
#line 155 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1;
#line 155 "Frontend/Parser/formula_unparse.k"
		fs=x->pred->count(fs);fs->aneg++;
#line  4770 "ast-system-unpk.cc"
			} else
		if ((this->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 154 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this/**/;
#line 154 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
#line 154 "Frontend/Parser/formula_unparse.k"
		fs=x->pred->count(fs);
#line  4779 "ast-system-unpk.cc"
			} else
	    {
#line 156 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    if ((this->tAtomicProposition_1->prod_sel() == sel_NNegation) && (phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 90 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this/**/;
#line 90 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1;
#line 90 "Frontend/Parser/formula_unparse.k"
		StatePredicate * t=x->pred->copy(NULL)->negate();kc_printer(t->toString(),kc_current_view);delete t;
#line  4796 "ast-system-unpk.cc"
			} else
		if ((this->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 89 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this/**/;
#line 89 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
#line 89 "Frontend/Parser/formula_unparse.k"
		kc_printer(x->pred->toString(),kc_current_view);
#line  4805 "ast-system-unpk.cc"
			} else
		    goto kc_unparsing_default;
	    break;
	}

#line  4811 "ast-system-unpk.cc"
	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}

void
impl_tConjunction_list::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case visible_enum: {
	    visible_class& kc_current_view=static_cast<visible_class&>(kc_current_view_base);
	    if ((this->tConjunction_list_1->prod_sel() == sel_NiltConjunction_list)) {
#line 1995 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
		kc::unparse(h, kc_printer, kc_current_view);
#line 1995 "Frontend/Parser/formula_unparse.k"
		containsNext = h -> containsNext;
#line  4839 "ast-system-unpk.cc"
			} else
	    {
#line 1996 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 1996 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
		kc::unparse(h, kc_printer, kc_current_view);
		kc::unparse(l, kc_printer, kc_current_view);
#line 1996 "Frontend/Parser/formula_unparse.k"
		containsNext = h -> containsNext || l -> containsNext;
#line  4850 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    if ((this->tConjunction_list_1->prod_sel() == sel_NiltConjunction_list)) {
#line 224 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
	    {
#line 225 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 225 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
		kc::unparse(h, kc_printer, kc_current_view);
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    if ((this->tConjunction_list_1->prod_sel() == sel_NiltConjunction_list)) {
#line 179 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 179 "Frontend/Parser/formula_unparse.k"
		h->fs=fs;
#line  4878 "ast-system-unpk.cc"
		kc::unparse(h, kc_printer, kc_current_view);
#line 179 "Frontend/Parser/formula_unparse.k"
		fs=h->fs;
#line  4882 "ast-system-unpk.cc"
			} else
	    {
#line 180 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 180 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
#line 180 "Frontend/Parser/formula_unparse.k"
		h->fs=fs;
#line  4891 "ast-system-unpk.cc"
		kc::unparse(h, kc_printer, kc_current_view);
#line 180 "Frontend/Parser/formula_unparse.k"
		l->fs=h->fs;
#line  4895 "ast-system-unpk.cc"
		kc::unparse(l, kc_printer, kc_current_view);
#line 180 "Frontend/Parser/formula_unparse.k"
		fs =l->fs;
#line  4899 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    if ((this->tConjunction_list_1->prod_sel() == sel_NiltConjunction_list)) {
#line 116 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
	    {
#line 117 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 117 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
		kc::unparse(h, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" AND "), kc_current_view); }
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  4922 "ast-system-unpk.cc"
	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		for (tConjunction_list iterator_ = this; iterator_->tConjunction_list_1 != 0; iterator_ = iterator_->tConjunction_list_1)
		    iterator_->tStatePredicate_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_tConjunction_list::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  4941 "ast-system-unpk.cc"
	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}

void
impl_tDisjunction_list::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case visible_enum: {
	    visible_class& kc_current_view=static_cast<visible_class&>(kc_current_view_base);
	    if ((this->tDisjunction_list_1->prod_sel() == sel_NiltDisjunction_list)) {
#line 1999 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
		kc::unparse(h, kc_printer, kc_current_view);
#line 1999 "Frontend/Parser/formula_unparse.k"
		containsNext = h -> containsNext;
#line  4968 "ast-system-unpk.cc"
			} else
	    {
#line 2000 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 2000 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
		kc::unparse(h, kc_printer, kc_current_view);
		kc::unparse(l, kc_printer, kc_current_view);
#line 2000 "Frontend/Parser/formula_unparse.k"
		containsNext = h -> containsNext || l -> containsNext;
#line  4979 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    if ((this->tDisjunction_list_1->prod_sel() == sel_NiltDisjunction_list)) {
#line 228 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
	    {
#line 229 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 229 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
		kc::unparse(h, kc_printer, kc_current_view);
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    if ((this->tDisjunction_list_1->prod_sel() == sel_NiltDisjunction_list)) {
#line 183 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 183 "Frontend/Parser/formula_unparse.k"
		h->fs=fs;
#line  5007 "ast-system-unpk.cc"
		kc::unparse(h, kc_printer, kc_current_view);
#line 183 "Frontend/Parser/formula_unparse.k"
		fs=h->fs;
#line  5011 "ast-system-unpk.cc"
			} else
	    {
#line 184 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 184 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
#line 184 "Frontend/Parser/formula_unparse.k"
		h->fs=fs;
#line  5020 "ast-system-unpk.cc"
		kc::unparse(h, kc_printer, kc_current_view);
#line 184 "Frontend/Parser/formula_unparse.k"
		l->fs=h->fs;
#line  5024 "ast-system-unpk.cc"
		kc::unparse(l, kc_printer, kc_current_view);
#line 184 "Frontend/Parser/formula_unparse.k"
		fs=l->fs;
#line  5028 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    if ((this->tDisjunction_list_1->prod_sel() == sel_NiltDisjunction_list)) {
#line 120 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
	    {
#line 121 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 121 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
		kc::unparse(h, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" OR "), kc_current_view); }
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  5051 "ast-system-unpk.cc"
	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		for (tDisjunction_list iterator_ = this; iterator_->tDisjunction_list_1 != 0; iterator_ = iterator_->tDisjunction_list_1)
		    iterator_->tStatePredicate_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_tDisjunction_list::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  5070 "ast-system-unpk.cc"
	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  5083 "ast-system-unpk.cc"
void
impl_tAtomicProposition_Deadlock::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case visible_enum: {
	    visible_class& kc_current_view=static_cast<visible_class&>(kc_current_view_base);
	    {
#line 2006 "Frontend/Parser/formula_unparse.k"

		for(arrayindex_t i = 0; i < Net::Card[TR];i++)
		{
		    Transition::Visible[i] = true;
		}
		containsNext = false;

#line  5099 "ast-system-unpk.cc"
	    }
	    break;
	}
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    {
#line 862 "Frontend/Parser/formula_unparse.k"

		StatePredicate *f = new DeadlockPredicate(true);

		formulas[id_stack.top()].push_back(f);    

#line  5112 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("DEADLOCK"), kc_current_view); }
	    }
	    break;
	}

#line  5124 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  5136 "ast-system-unpk.cc"
void
impl_tAtomicProposition_NoDeadlock::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case visible_enum: {
	    visible_class& kc_current_view=static_cast<visible_class&>(kc_current_view_base);
	    {
#line 2015 "Frontend/Parser/formula_unparse.k"

		for(arrayindex_t i = 0; i < Net::Card[TR];i++)
		{
		    Transition::Visible[i] = true;
		}
		containsNext = false;

#line  5152 "ast-system-unpk.cc"
	    }
	    break;
	}
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    {
#line 868 "Frontend/Parser/formula_unparse.k"

		StatePredicate *f = new DeadlockPredicate(false);

		formulas[id_stack.top()].push_back(f);    

#line  5165 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("NOT DEADLOCK"), kc_current_view); }
	    }
	    break;
	}

#line  5177 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  5189 "ast-system-unpk.cc"
void
impl_tAtomicProposition_False::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case visible_enum: {
	    visible_class& kc_current_view=static_cast<visible_class&>(kc_current_view_base);
	    {
#line 2004 "Frontend/Parser/formula_unparse.k"
		containsNext = false;
#line  5199 "ast-system-unpk.cc"
	    }
	    break;
	}
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    {
#line 856 "Frontend/Parser/formula_unparse.k"

		StatePredicate *f = new FalsePredicate();

		formulas[id_stack.top()].push_back(f);    

#line  5212 "ast-system-unpk.cc"
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 188 "Frontend/Parser/formula_unparse.k"
		fs->cont++;
#line  5221 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("FALSE"), kc_current_view); }
	    }
	    break;
	}

#line  5233 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  5245 "ast-system-unpk.cc"
void
impl_tAtomicProposition_True::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case visible_enum: {
	    visible_class& kc_current_view=static_cast<visible_class&>(kc_current_view_base);
	    {
#line 2003 "Frontend/Parser/formula_unparse.k"
		containsNext = false;
#line  5255 "ast-system-unpk.cc"
	    }
	    break;
	}
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    {
#line 850 "Frontend/Parser/formula_unparse.k"

		StatePredicate *f = new TruePredicate();

		formulas[id_stack.top()].push_back(f);    

#line  5268 "ast-system-unpk.cc"
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 187 "Frontend/Parser/formula_unparse.k"
		fs->taut++;
#line  5277 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("TRUE"), kc_current_view); }
	    }
	    break;
	}

#line  5289 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  5301 "ast-system-unpk.cc"
void
impl_tAtomicProposition_NNegation::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  5307 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  5320 "ast-system-unpk.cc"
void
impl_tAtomicProposition_Elementary::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  5326 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  5338 "ast-system-unpk.cc"
void
impl_tTerm_Complex::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  5344 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  5356 "ast-system-unpk.cc"
void
impl_tBuechiAutomata_BuechiNull::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case buechi_enum: {
	    buechi_class& kc_current_view=static_cast<buechi_class&>(kc_current_view_base);
	    {
#line 896 "Frontend/Parser/formula_unparse.k"
		const tBuechiAutomata b = this/**/;
#line 896 "Frontend/Parser/formula_unparse.k"
		RT::rep->message("NULL BUECHI"); b->automata = 0; 
#line  5368 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

#line  5379 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  5391 "ast-system-unpk.cc"
void
impl_tBuechiAutomata_BuechiAutomaton::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case buechi_enum: {
	    buechi_class& kc_current_view=static_cast<buechi_class&>(kc_current_view_base);
	    {
#line 897 "Frontend/Parser/formula_unparse.k"
		const tBuechiAutomata b = this/**/;
#line 897 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules trans = this->tBuechiRules_1;
#line 897 "Frontend/Parser/formula_unparse.k"
		const tAcceptingSet accept = this->tAcceptingSet_1;
		kc::unparse(trans, kc_printer, kc_current_view);
		kc::unparse(accept, kc_printer, kc_current_view);
#line 900 "Frontend/Parser/formula_unparse.k"




		uint32_t number_of_states = states_to_interal.size();


		b->automata = new BuechiAutomata();
		b->automata->cardStates = number_of_states;






		b->automata->cardTransitions = new uint32_t[number_of_states]();
		b->automata->nextstate = new uint32_t*[number_of_states]();
		b->automata->guard = new StatePredicate**[number_of_states]();
		for (uint32_t i = 0; i < number_of_states; i++){
		    b->automata->cardTransitions[i] = transitions[i].size();
		    b->automata->nextstate[i] = new uint32_t[transitions[i].size()]();
		    b->automata->guard[i] = new StatePredicate*[transitions[i].size()]();
		    for (uint32_t j = 0; j < transitions[i].size(); j++){
			b->automata->guard[i][j] = predicates[transitions[i][j].first];
			b->automata->nextstate[i][j] = transitions[i][j].second;
		    }
		}



		b->automata->isStateAccepting = new bool[number_of_states]();
		for (__typeof__(acceptingset.begin()) i = acceptingset.begin(); i != acceptingset.end(); i++)
		b->automata->isStateAccepting[*i] = true;

#line  5442 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 129 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules trans = this->tBuechiRules_1;
#line 129 "Frontend/Parser/formula_unparse.k"
		const tAcceptingSet accept = this->tAcceptingSet_1;
		kc::unparse(trans, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\n"), kc_current_view); }
		kc::unparse(accept, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  5460 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  5473 "ast-system-unpk.cc"
void
impl_tBuechiRules_BuechiRules::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case buechi_enum: {
	    buechi_class& kc_current_view=static_cast<buechi_class&>(kc_current_view_base);
	    {
#line 960 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules lrules = this->tBuechiRules_1;
#line 960 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules rrules = this->tBuechiRules_2;
		kc::unparse(lrules, kc_printer, kc_current_view);
		kc::unparse(rrules, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 135 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules a = this->tBuechiRules_1;
#line 135 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules b = this->tBuechiRules_2;
		kc::unparse(a, kc_printer, kc_current_view);
		{ kc_printer(kc_t("&"), kc_current_view); }
		kc::unparse(b, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  5504 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  5517 "ast-system-unpk.cc"
void
impl_tBuechiRules_ExpandedBuechiRule::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case buechi_enum: {
	    buechi_class& kc_current_view=static_cast<buechi_class&>(kc_current_view_base);
	    {
#line 937 "Frontend/Parser/formula_unparse.k"
		const integer from = this->integer_1;
#line 937 "Frontend/Parser/formula_unparse.k"
		const tFormula formula = this->tFormula_1;
#line 937 "Frontend/Parser/formula_unparse.k"
		const integer to = this->integer_2;
#line 938 "Frontend/Parser/formula_unparse.k"


		formula->unparse(myprinter, kc::internal);
		StatePredicate* result = formula->formula;






		uint32_t formula_number = (uint32_t)(predicates.size());
		predicates[formula_number] = result;

		uint32_t from_number = get_state_number(from->value);
		uint32_t to_number = get_state_number(to->value);

		transitions[from_number].push_back(std::make_pair(formula_number, to_number));

#line  5550 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 134 "Frontend/Parser/formula_unparse.k"
		const integer from = this->integer_1;
#line 134 "Frontend/Parser/formula_unparse.k"
		const tFormula formula = this->tFormula_1;
#line 134 "Frontend/Parser/formula_unparse.k"
		const integer to = this->integer_2;
		kc::unparse(from, kc_printer, kc_current_view);
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(formula, kc_printer, kc_current_view);
		{ kc_printer(kc_t(") -> "), kc_current_view); }
		kc::unparse(to, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\n"), kc_current_view); }
	    }
	    break;
	}

#line  5573 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  5586 "ast-system-unpk.cc"
void
impl_tBuechiRules_BuechiRule::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 133 "Frontend/Parser/formula_unparse.k"
		const integer i = this->integer_1;
#line 133 "Frontend/Parser/formula_unparse.k"
		const tTransitionRules t = this->tTransitionRules_1;
		{ kc_printer(kc_t("STATE"), kc_current_view); }
		kc::unparse(i, kc_printer, kc_current_view);
		kc::unparse(t, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  5605 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  5618 "ast-system-unpk.cc"
void
impl_tBuechiRules_EmptyBuechiRules::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case buechi_enum: {
	    buechi_class& kc_current_view=static_cast<buechi_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

#line  5636 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  5648 "ast-system-unpk.cc"
void
impl_tTransitionRules_TransitionRules::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 139 "Frontend/Parser/formula_unparse.k"
		const tTransitionRules a = this->tTransitionRules_1;
#line 139 "Frontend/Parser/formula_unparse.k"
		const tTransitionRules b = this->tTransitionRules_2;
		kc::unparse(a, kc_printer, kc_current_view);
		{ kc_printer(kc_t("&"), kc_current_view); }
		kc::unparse(b, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  5667 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  5680 "ast-system-unpk.cc"
void
impl_tTransitionRules_TransitionRule::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 138 "Frontend/Parser/formula_unparse.k"
		const tFormula formu = this->tFormula_1;
#line 138 "Frontend/Parser/formula_unparse.k"
		const integer i = this->integer_1;
		kc::unparse(formu, kc_printer, kc_current_view);
		{ kc_printer(kc_t("->"), kc_current_view); }
		kc::unparse(i, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  5699 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  5712 "ast-system-unpk.cc"
void
impl_tTransitionRules_EmptyTransitionRules::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

#line  5724 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  5736 "ast-system-unpk.cc"
void
impl_tAcceptingSet_AcceptingSet::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case buechi_enum: {
	    buechi_class& kc_current_view=static_cast<buechi_class&>(kc_current_view_base);
	    {
#line 971 "Frontend/Parser/formula_unparse.k"
		const tAcceptingSet set1 = this->tAcceptingSet_1;
#line 971 "Frontend/Parser/formula_unparse.k"
		const tAcceptingSet set2 = this->tAcceptingSet_2;
		kc::unparse(set1, kc_printer, kc_current_view);
		kc::unparse(set2, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

#line  5760 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  5773 "ast-system-unpk.cc"
void
impl_tAcceptingSet_AcceptingState::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case buechi_enum: {
	    buechi_class& kc_current_view=static_cast<buechi_class&>(kc_current_view_base);
	    {
#line 965 "Frontend/Parser/formula_unparse.k"
		const integer state = this->integer_1;
#line 966 "Frontend/Parser/formula_unparse.k"

		acceptingset.insert(get_state_number(state->value));

#line  5787 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

#line  5798 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  5811 "ast-system-unpk.cc"
void
impl_tAcceptingSet_EmptyAcceptingSet::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case buechi_enum: {
	    buechi_class& kc_current_view=static_cast<buechi_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

#line  5829 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  5841 "ast-system-unpk.cc"
void
impl_net_Net::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 1541 "Frontend/Parser/formula_unparse.k"
		const casestring c = this->casestring_1;
#line 1541 "Frontend/Parser/formula_unparse.k"
		const definitionsList d = this->definitionsList_1;
#line 1541 "Frontend/Parser/formula_unparse.k"
		const placeblocklist p = this->placeblocklist_1;
#line 1541 "Frontend/Parser/formula_unparse.k"
		const marking m = this->marking_1;
#line 1541 "Frontend/Parser/formula_unparse.k"
		const transition t = this->transition_1;
		kc::unparse(c, kc_printer, kc_current_view);
		kc::unparse(d, kc_printer, kc_current_view);
		kc::unparse(p, kc_printer, kc_current_view);
		kc::unparse(m, kc_printer, kc_current_view);
		kc::unparse(t, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  5868 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  5881 "ast-system-unpk.cc"
void
impl_definitionsList_DefinitionsList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 1544 "Frontend/Parser/formula_unparse.k"
		const definitionsList l = this->definitionsList_1;
#line 1544 "Frontend/Parser/formula_unparse.k"
		const definitions d = this->definitions_1;
		kc::unparse(l, kc_printer, kc_current_view);
		kc::unparse(d, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  5899 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  5912 "ast-system-unpk.cc"
void
impl_definitionsList_EmptyDefinitionsList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

#line  5924 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  5936 "ast-system-unpk.cc"
void
impl_definitions_Function::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 1569 "Frontend/Parser/formula_unparse.k"
		const type t = this->type_1;
#line 1569 "Frontend/Parser/formula_unparse.k"
		const casestring c = this->casestring_1;
#line 1569 "Frontend/Parser/formula_unparse.k"
		const arrayList a = this->arrayList_1;
#line 1569 "Frontend/Parser/formula_unparse.k"
		const functionParametersList f = this->functionParametersList_1;
#line 1569 "Frontend/Parser/formula_unparse.k"
		const block b = this->block_1;
		kc::unparse(t, kc_printer, kc_current_view);
		kc::unparse(c, kc_printer, kc_current_view);
#line 1570 "Frontend/Parser/formula_unparse.k"

		a -> inherited_type = t;

#line  5960 "ast-system-unpk.cc"
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(f, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
#line 1574 "Frontend/Parser/formula_unparse.k"





#line  5970 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  5975 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  5988 "ast-system-unpk.cc"
void
impl_definitions_Sort::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 1560 "Frontend/Parser/formula_unparse.k"
		const type t = this->type_1;
#line 1560 "Frontend/Parser/formula_unparse.k"
		const casestring c = this->casestring_1;
#line 1560 "Frontend/Parser/formula_unparse.k"
		const arrayList a = this->arrayList_1;
		kc::unparse(t, kc_printer, kc_current_view);
		kc::unparse(c, kc_printer, kc_current_view);
#line 1561 "Frontend/Parser/formula_unparse.k"

		a -> inherited_type = t;

#line  6008 "ast-system-unpk.cc"
		kc::unparse(a, kc_printer, kc_current_view);
#line 1565 "Frontend/Parser/formula_unparse.k"



#line  6014 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  6019 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  6032 "ast-system-unpk.cc"
void
impl_definitions_Constant::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 1546 "Frontend/Parser/formula_unparse.k"
		const type t = this->type_1;
#line 1546 "Frontend/Parser/formula_unparse.k"
		const casestring c = this->casestring_1;
#line 1546 "Frontend/Parser/formula_unparse.k"
		const arrayList a = this->arrayList_1;
#line 1546 "Frontend/Parser/formula_unparse.k"
		const expression e = this->expression_1;
		kc::unparse(t, kc_printer, kc_current_view);
		kc::unparse(c, kc_printer, kc_current_view);
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(e, kc_printer, kc_current_view);
#line 1547 "Frontend/Parser/formula_unparse.k"


		if(! (e->is_constant))
		{

		}






#line  6065 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  6070 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  6083 "ast-system-unpk.cc"
void
impl_type_TypeBlack::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 1657 "Frontend/Parser/formula_unparse.k"

		is_finite = true;
		is_scalar = true;
		size = 1;

#line  6097 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  6102 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  6114 "ast-system-unpk.cc"
void
impl_type_TypeArray::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  6120 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  6133 "ast-system-unpk.cc"
void
impl_type_TypeMultiset::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 1645 "Frontend/Parser/formula_unparse.k"
		const type t = this->type_1;
		kc::unparse(t, kc_printer, kc_current_view);
#line 1646 "Frontend/Parser/formula_unparse.k"

		if(! (t->is_finite))
		{

		}
		is_finite = false;
		is_scalar = false;
		size = 0; 

#line  6154 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  6159 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  6172 "ast-system-unpk.cc"
void
impl_type_TypeInt::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 1639 "Frontend/Parser/formula_unparse.k"

		is_finite = false;
		is_scalar = true;
		size = 0; 

#line  6186 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  6191 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  6203 "ast-system-unpk.cc"
void
impl_type_TypeStruct::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 1631 "Frontend/Parser/formula_unparse.k"
		const structTypeList s = this->structTypeList_1;
		kc::unparse(s, kc_printer, kc_current_view);
#line 1632 "Frontend/Parser/formula_unparse.k"

		size = s -> size;
		is_finite = s -> is_finite;
		is_scalar = false;

#line  6220 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  6225 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  6238 "ast-system-unpk.cc"
void
impl_type_TypeIntInterval::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 1610 "Frontend/Parser/formula_unparse.k"
		const expression e = this->expression_1;
#line 1610 "Frontend/Parser/formula_unparse.k"
		const expression f = this->expression_2;
		kc::unparse(e, kc_printer, kc_current_view);
		kc::unparse(f, kc_printer, kc_current_view);
#line 1611 "Frontend/Parser/formula_unparse.k"

		if(!(e->is_constant && f->is_constant))
		{

		}
		if(!(e -> is_scalar && f -> is_scalar))
		{

		}
		arrayindex_t left = *(reinterpret_cast<arrayindex_t *>(e->value));
		arrayindex_t right = *(reinterpret_cast<arrayindex_t *>(f->value));
		if(right < left)
		{

		}
		is_finite = true;
		is_scalar = true;
		size = right - left +1;

#line  6272 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  6277 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  6290 "ast-system-unpk.cc"
void
impl_type_TypeIdent::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 1603 "Frontend/Parser/formula_unparse.k"
		const casestring c = this->casestring_1;
#line 1604 "Frontend/Parser/formula_unparse.k"




#line  6305 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  6310 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  6323 "ast-system-unpk.cc"
void
impl_type_TypeEnum::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 1590 "Frontend/Parser/formula_unparse.k"
		const identList i = this->identList_1;
		kc::unparse(i, kc_printer, kc_current_view);
#line 1591 "Frontend/Parser/formula_unparse.k"

		size = i -> nrvalues;
		if(size == 0)
		{

		}
		is_finite = true;
		is_scalar = true;


#line  6345 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  6350 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  6363 "ast-system-unpk.cc"
void
impl_type_TypeBool::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 1582 "Frontend/Parser/formula_unparse.k"

		size = 2;
		is_finite = true;
		is_scalar = true;


#line  6378 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  6383 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  6395 "ast-system-unpk.cc"
void
impl_optionalNumber_OptNumber::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 1671 "Frontend/Parser/formula_unparse.k"
		const integer i = this->integer_1;
#line 1672 "Frontend/Parser/formula_unparse.k"

		value = i-> value;
		set = true;

#line  6410 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  6415 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  6428 "ast-system-unpk.cc"
void
impl_optionalNumber_EmptyOptNumber::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 1665 "Frontend/Parser/formula_unparse.k"

		value = ARRAYINDEX_T_MAX;
		set = false;

#line  6441 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  6446 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  6458 "ast-system-unpk.cc"
void
impl_identList_IdentList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 1685 "Frontend/Parser/formula_unparse.k"
		const identList i = this->identList_1;
#line 1685 "Frontend/Parser/formula_unparse.k"
		const idents d = this->idents_1;
		kc::unparse(i, kc_printer, kc_current_view);
		kc::unparse(d, kc_printer, kc_current_view);
#line 1686 "Frontend/Parser/formula_unparse.k"

		nrvalues = i -> nrvalues + 1;
		if(d -> value <= i -> maxvalue)
		{

		}
		if(!(d -> set))
		{
		    d -> value = i -> maxvalue + 1;
		}

		maxvalue = d -> value;


#line  6487 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  6492 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  6505 "ast-system-unpk.cc"
void
impl_identList_EmptyIdentList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 1679 "Frontend/Parser/formula_unparse.k"

		maxvalue = 0;
		nrvalues = 0;

#line  6518 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  6523 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  6535 "ast-system-unpk.cc"
void
impl_idents_Idents::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 1702 "Frontend/Parser/formula_unparse.k"
		const casestring c = this->casestring_1;
#line 1702 "Frontend/Parser/formula_unparse.k"
		const optionalNumber o = this->optionalNumber_1;
		kc::unparse(c, kc_printer, kc_current_view);
		kc::unparse(o, kc_printer, kc_current_view);
#line 1703 "Frontend/Parser/formula_unparse.k"

		value = o -> value;
		set = o -> set;

#line  6554 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  6559 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  6572 "ast-system-unpk.cc"
void
impl_structTypeList_StructTypeList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 1716 "Frontend/Parser/formula_unparse.k"
		const structTypeList l = this->structTypeList_1;
#line 1716 "Frontend/Parser/formula_unparse.k"
		const structType s = this->structType_1;
		kc::unparse(l, kc_printer, kc_current_view);
		kc::unparse(s, kc_printer, kc_current_view);
#line 1717 "Frontend/Parser/formula_unparse.k"

		size = l -> size * s -> size;
		nrcomponents = l -> nrcomponents + 1;
		is_finite = (l -> is_finite) && (s -> is_finite);

#line  6592 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  6597 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  6610 "ast-system-unpk.cc"
void
impl_structTypeList_EmptyStructTypeList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 1710 "Frontend/Parser/formula_unparse.k"

		size = 0;
		nrcomponents = 0;
		is_finite = true;

#line  6624 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  6629 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  6641 "ast-system-unpk.cc"
void
impl_structType_StructType::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 1724 "Frontend/Parser/formula_unparse.k"
		const type t = this->type_1;
#line 1724 "Frontend/Parser/formula_unparse.k"
		const casestring c = this->casestring_1;
#line 1724 "Frontend/Parser/formula_unparse.k"
		const arrayList a = this->arrayList_1;
		kc::unparse(t, kc_printer, kc_current_view);
		kc::unparse(c, kc_printer, kc_current_view);
#line 1725 "Frontend/Parser/formula_unparse.k"

		a -> inherited_type = t;

#line  6661 "ast-system-unpk.cc"
		kc::unparse(a, kc_printer, kc_current_view);
#line 1729 "Frontend/Parser/formula_unparse.k"

		size = t -> size * a -> nrelements;
		is_finite = t -> is_finite;
		is_scalar = false;

#line  6669 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  6674 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  6687 "ast-system-unpk.cc"
void
impl_varOrArray_VarOrArray::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 1736 "Frontend/Parser/formula_unparse.k"
		const casestring c = this->casestring_1;
#line 1736 "Frontend/Parser/formula_unparse.k"
		const arrayList a = this->arrayList_1;
#line 1737 "Frontend/Parser/formula_unparse.k"

		a -> inherited_type = inherited_type;

#line  6703 "ast-system-unpk.cc"
		kc::unparse(c, kc_printer, kc_current_view);
		kc::unparse(a, kc_printer, kc_current_view);
#line 1741 "Frontend/Parser/formula_unparse.k"

		type = a -> type;

#line  6710 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  6715 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  6728 "ast-system-unpk.cc"
void
impl_arrayList_ArrayList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 1754 "Frontend/Parser/formula_unparse.k"
		const arrayList a = this->arrayList_1;
#line 1754 "Frontend/Parser/formula_unparse.k"
		const expression e = this->expression_1;
#line 1755 "Frontend/Parser/formula_unparse.k"

		a -> inherited_type = inherited_type;

#line  6744 "ast-system-unpk.cc"
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(e, kc_printer, kc_current_view);
#line 1759 "Frontend/Parser/formula_unparse.k"

		if(!(e -> is_constant))
		{

		}
		if(e -> value == 0)
		{

		}
		nrdimensions = a -> nrdimensions + 1;


		type -> size = nrelements * a -> type -> size;
		type -> is_finite = a -> type -> is_finite;
		type -> is_scalar = false;


#line  6765 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  6770 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  6783 "ast-system-unpk.cc"
void
impl_arrayList_EmptyArrayList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 1748 "Frontend/Parser/formula_unparse.k"

		nrdimensions = 0;
		nrelements = 1;
		type = inherited_type;

#line  6797 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  6802 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  6814 "ast-system-unpk.cc"
void
impl_functionParametersList_FunctionParametersList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  6820 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  6833 "ast-system-unpk.cc"
void
impl_functionParametersList_EmptyFunctionParametersList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  6839 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  6851 "ast-system-unpk.cc"
void
impl_functionParameters_FunctionParameters::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  6857 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  6870 "ast-system-unpk.cc"
void
impl_expression_ExprAll::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  6876 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  6889 "ast-system-unpk.cc"
void
impl_expression_ExprOtherIf::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  6895 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  6908 "ast-system-unpk.cc"
void
impl_expression_ExprCommaSeparated::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  6914 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  6927 "ast-system-unpk.cc"
void
impl_expression_FunctionCall::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  6933 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  6946 "ast-system-unpk.cc"
void
impl_expression_ExprGreaterOrEqual::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  6952 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  6965 "ast-system-unpk.cc"
void
impl_expression_ExprLessOrEqual::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  6971 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  6984 "ast-system-unpk.cc"
void
impl_expression_ExprGreaterThan::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  6990 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7003 "ast-system-unpk.cc"
void
impl_expression_ExprLessThan::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7009 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7022 "ast-system-unpk.cc"
void
impl_expression_ExprNotEqual::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7028 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7041 "ast-system-unpk.cc"
void
impl_expression_ExprEquivalent::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7047 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7060 "ast-system-unpk.cc"
void
impl_expression_ExprFalse::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7066 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  7078 "ast-system-unpk.cc"
void
impl_expression_ExprTrue::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7084 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  7096 "ast-system-unpk.cc"
void
impl_expression_ExprOr::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7102 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7115 "ast-system-unpk.cc"
void
impl_expression_ExprAnd::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7121 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7134 "ast-system-unpk.cc"
void
impl_expression_NotExpr::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7140 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7153 "ast-system-unpk.cc"
void
impl_expression_ExprNumber::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7159 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7172 "ast-system-unpk.cc"
void
impl_expression_ExprModulo::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7178 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7191 "ast-system-unpk.cc"
void
impl_expression_ExprDivision::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7197 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7210 "ast-system-unpk.cc"
void
impl_expression_ExprMultiplication::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7216 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7229 "ast-system-unpk.cc"
void
impl_expression_ExprSubtraction::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7235 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7248 "ast-system-unpk.cc"
void
impl_expression_ExprAddition::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7254 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7267 "ast-system-unpk.cc"
void
impl_expression_NegativeExpr::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7273 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7286 "ast-system-unpk.cc"
void
impl_expression_PositiveExpr::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7292 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7305 "ast-system-unpk.cc"
void
impl_expression_ValDecrement::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7311 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7324 "ast-system-unpk.cc"
void
impl_expression_ValIncrement::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7330 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7343 "ast-system-unpk.cc"
void
impl_expression_DecrementVal::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7349 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7362 "ast-system-unpk.cc"
void
impl_expression_IncrementVal::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7368 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7381 "ast-system-unpk.cc"
void
impl_expression_AssignMod::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7387 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7400 "ast-system-unpk.cc"
void
impl_expression_AssignDivide::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7406 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7419 "ast-system-unpk.cc"
void
impl_expression_AssignTimes::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7425 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7438 "ast-system-unpk.cc"
void
impl_expression_AssignMinus::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7444 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7457 "ast-system-unpk.cc"
void
impl_expression_AssignPlus::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7463 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7476 "ast-system-unpk.cc"
void
impl_expression_AssignEqual::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7482 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7495 "ast-system-unpk.cc"
void
impl_expression_ExprInitializerList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7501 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7514 "ast-system-unpk.cc"
void
impl_expression_ExprLeftvalue::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7520 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7533 "ast-system-unpk.cc"
void
impl_leftvalue_LeftValDot::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7539 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7552 "ast-system-unpk.cc"
void
impl_leftvalue_LeftValBrackets::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7558 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7571 "ast-system-unpk.cc"
void
impl_leftvalue_LeftValIdent::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7577 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7590 "ast-system-unpk.cc"
void
impl_expressionlist_ExpressionList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7596 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7609 "ast-system-unpk.cc"
void
impl_expressionlist_EmptyExpressionList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7615 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  7627 "ast-system-unpk.cc"
void
impl_initializerList_ExprInBracesColon::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7633 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7646 "ast-system-unpk.cc"
void
impl_initializerList_ExprInBraces::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7652 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7665 "ast-system-unpk.cc"
void
impl_expressionListColon_ExpressionListColon::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7671 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7684 "ast-system-unpk.cc"
void
impl_expressionListColon_EmptyExpressionListColon::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7690 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  7702 "ast-system-unpk.cc"
void
impl_placeblocklist_PlaceBlockList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7708 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7721 "ast-system-unpk.cc"
void
impl_placeblocklist_EmptyPlaceBlockList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7727 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  7739 "ast-system-unpk.cc"
void
impl_optSafe_Safe::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7745 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7758 "ast-system-unpk.cc"
void
impl_optSafe_EmptySafe::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7764 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  7776 "ast-system-unpk.cc"
void
impl_place_Place::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7782 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7795 "ast-system-unpk.cc"
void
impl_placelist_PlaceList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7801 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7814 "ast-system-unpk.cc"
void
impl_placelist_EmptyPlaceList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7820 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  7832 "ast-system-unpk.cc"
void
impl_placeblock_PlaceBlock::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7838 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7851 "ast-system-unpk.cc"
void
impl_marking_Marking::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7857 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7870 "ast-system-unpk.cc"
void
impl_marking_EmptyMarking::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7876 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  7888 "ast-system-unpk.cc"
void
impl_transition_Transition::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7894 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7907 "ast-system-unpk.cc"
void
impl_transition_EmptyTransition::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7913 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  7925 "ast-system-unpk.cc"
void
impl_fairness_StrongFair::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7931 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  7943 "ast-system-unpk.cc"
void
impl_fairness_WeakFair::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7949 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  7961 "ast-system-unpk.cc"
void
impl_fairness_EmptyFairness::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7967 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  7979 "ast-system-unpk.cc"
void
impl_variable_Variable::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  7985 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7998 "ast-system-unpk.cc"
void
impl_variable_EmptyVariable::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8004 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  8016 "ast-system-unpk.cc"
void
impl_varOrArrayList_VarOrArrayList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8022 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8035 "ast-system-unpk.cc"
void
impl_varOrArrayList_EmptyVarOrArrayList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8041 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  8053 "ast-system-unpk.cc"
void
impl_guard_Guard::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8059 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8072 "ast-system-unpk.cc"
void
impl_identExprList_IdentExprList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8078 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8091 "ast-system-unpk.cc"
void
impl_identExprList_EmptyIdentExprList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8097 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  8109 "ast-system-unpk.cc"
void
impl_block_Block::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8115 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8128 "ast-system-unpk.cc"
void
impl_declarationOrStatement_DeclOrStatemStatement::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8134 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8147 "ast-system-unpk.cc"
void
impl_declarationOrStatement_DeclOrStatemDeclaration::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8153 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8166 "ast-system-unpk.cc"
void
impl_declarationOrStatement_EmptyDeclarationOrStatement::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8172 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  8184 "ast-system-unpk.cc"
void
impl_declaration_Declaration::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8190 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8203 "ast-system-unpk.cc"
void
impl_statement_StatementSkip::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8209 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  8221 "ast-system-unpk.cc"
void
impl_statement_StatementReturn::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8227 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8240 "ast-system-unpk.cc"
void
impl_statement_StatementContinue::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8246 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  8258 "ast-system-unpk.cc"
void
impl_statement_StatementBreak::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8264 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  8276 "ast-system-unpk.cc"
void
impl_statement_StatementSwitch::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8282 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8295 "ast-system-unpk.cc"
void
impl_statement_StatementForAll::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8301 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8314 "ast-system-unpk.cc"
void
impl_statement_StatementForIdentColon::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8320 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8333 "ast-system-unpk.cc"
void
impl_statement_StatementForTypeExpr::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8339 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8352 "ast-system-unpk.cc"
void
impl_statement_StatementForExpr::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8358 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8371 "ast-system-unpk.cc"
void
impl_statement_StatementDoWhile::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8377 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8390 "ast-system-unpk.cc"
void
impl_statement_StatementWhile::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8396 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8409 "ast-system-unpk.cc"
void
impl_statement_StatementIf::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8415 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8428 "ast-system-unpk.cc"
void
impl_statement_StatementExprSemicolon::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8434 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8447 "ast-system-unpk.cc"
void
impl_statement_StatementBlock::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8453 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8466 "ast-system-unpk.cc"
void
impl_switchCase_SwitchDefault::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8472 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8485 "ast-system-unpk.cc"
void
impl_switchCase_SwitchCase::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8491 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8504 "ast-system-unpk.cc"
void
impl_switchCaseList_SwitchCaseList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8510 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  8523 "ast-system-unpk.cc"
void
impl_switchCaseList_EmptySwitchCaseList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8529 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


} // namespace kc
