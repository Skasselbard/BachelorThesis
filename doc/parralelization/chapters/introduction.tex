% !TEX root = ../main.tex
\chapter{Introduction}
\label{introduction}

The LowLevelAnalyzer (LoLA) is a model checking tool for Petri nets, but until today it utilizes only a single thread in productive use.

\paragraph*{Petri net basics}
A Petri net is a mathematical construction to describe the behavior of distributed systems. Petri nets were first defined by Carl Adam Petri\cite{Petri1962kommunikation}. A Petri net is defined by a five-tuple: (P, T, F, W, $m_0$). It consists of \textbf{places} (P) that can hold infinite \textbf{tokens} (or marks). The initial amount of tokens on each place is defined by the initial \textbf{marking} ($m_0$). Places can be connected with transitions (T) via directed \textbf{edges} (F for flow). Places cannot be connected to other places and transitions cannot be connected to other transitions.

For example, net D in Figure \ref{petrNetExamples} has four places and three transitions. The top place holds two tokens. Its \textbf{preset} is empty because there are no incoming edges and its \textbf{postset} contains only the top transition because the only outgoing edge points there. The top transition can be \textbf{fired} since all places in its preset (the top place) are marked with an equal or greater amount of tokens than the \textbf{weight} (W) of the connecting edges. Firing a transition will \textbf{consume} tokens from all places that point \textbf{to} the transition with a connecting edge. At the same time, it will \textbf{produce} tokens on all places where an edge points \textbf{from} this transition. This means that firing the top transition will consume one token from the top place and will produce one token on each center place (two tokens in total). After that, all transitions are \textbf{activated}, because the places in their preset are sufficiently marked.

Besides activated transitions, there are other properties\cite{murata1989petri} that can be checked in Petri nets. For example, net B in Figure \ref{petrNetExamples} is \textbf{dead}. A net is dead if all its transitions are dead. And a transition is dead if there is no reachable marking in which it will be activated again. A Petri net might not be initially dead, but it may become dead if a particular sequence of transitions where fired.

Contrarily Net C is \textbf{alive} because all its transitions are alive. Its only transition is alive because it can always be fired in every possibly net state (there are other definitions of liveness\cite{murata1989petri}). However, a transition might neither be alive nor dead if it is possible to fire it in a reachable net state, but not in all possible net states.

These and other properties can soundly be formulated mathematically which makes Petri nets very useful for model checking.

\input{pictures/petriExamples}

\paragraph*{LoLA}
LoLAs development started in 1998. It was developed to be used by third party tools to check properties of Petri nets\cite{schmidt2000lola}. Since then it was steadily updated to compete with other - state of the art - tools. LoLa was repeatedly decorated with  prizes in a model checking contest with a focus on Petri nets \cite{MCC2017}.
The internal property evaluation, however, is still most performant single threaded. To evaluate a property of a Petri net, LoLA searches all necessary net states that can be reached from the initial one. The search is a depth-first search on a directed graph, which is discovered during the search itself.

For the specialized search in LoLA, a previous attempt of a parallel implementation exists. Unfortunately, the performance is usually about the same as the single threaded approach. But it can even get worse the more threads are used.

In this work, we will explore LoLA to find the part which is not performing as expected. The most important task is to find the bottleneck. We will measure the performance of LoLA so that we can compare the base version with an improved one that we will develop. The improved version should hopefully outperform the single-threaded algorithm with a reasonable amount of threads. Additionally, a desirable result would show a linear scaling of the performance with the number of threads.
