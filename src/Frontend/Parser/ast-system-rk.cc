/* translation of file(s)
	"Frontend/Parser/formula_abstract.k"
	"Frontend/Parser/formula_rewrite.k"
	"Frontend/Parser/formula_unparse.k"
 */
/* generated by:
 *  @(#)$Author: Kimwitu++ version 2.3.13 (C) 1998-2008 Humboldt-Universitaet zu Berlin $
 */
#define KC_REWRITE

#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>
#include "ast-system-k.h"
#include "ast-system-rk.h"


namespace kc {
base_rview_class base_rview;
goodbye_doublearrows_class goodbye_doublearrows;
goodbye_singlearrows_class goodbye_singlearrows;
goodbye_xor_class goodbye_xor;
tautology_class tautology;
emptyquantifiers_class emptyquantifiers;
singletemporal_class singletemporal;
simpleneg_class simpleneg;
booleanlists_class booleanlists;
ctloperators_class ctloperators;
rbuechi_class rbuechi;

impl_rviews rviews[] = {
    {"base_rview",&base_rview},
    {"goodbye_doublearrows",&goodbye_doublearrows},
    {"goodbye_singlearrows",&goodbye_singlearrows},
    {"goodbye_xor",&goodbye_xor},
    {"tautology",&tautology},
    {"emptyquantifiers",&emptyquantifiers},
    {"singletemporal",&singletemporal},
    {"simpleneg",&simpleneg},
    {"booleanlists",&booleanlists},
    {"ctloperators",&ctloperators},
    {"rbuechi",&rbuechi},
    {0,0}
};

} // namespace kc
namespace kc { }
using namespace kc;
/* included stuff */
#line 24 "Frontend/Parser/formula_rewrite.k"
#include <Frontend/Parser/ast-system-rk.h>
#include <CoverGraph/CoverGraph.h>
#include <Net/Marking.h>
#include <Formula/StatePredicate/DeadlockPredicate.h>
#include <Formula/StatePredicate/StatePredicate.h>
#include <Formula/StatePredicate/MagicNumber.h>
#include <Net/Net.h>

/*
Uncomment the next line to define a debug function that traces all matches in
the rewriting process.
*/
//#define KC_TRACE_REWRITE_RESULT(VIEW,FILE,LINE,NODE) { RT::rep->status("rewrite %s:%d", FILE, LINE); }

/*!
Count the rule applications
*/
size_t rule_applications = 0;
#define KC_TRACE_REWRITE_MATCH(VIEW,FILE,LINE,NODE) { ++rule_applications; }


#line  73 "ast-system-rk.cc"
/* end included stuff */


namespace kc {

#ifndef KC_TRACE_PROVIDED
#define KC_TRACE_PROVIDED(COND,FILE,LINE,NODE) COND
#endif
#ifndef KC_TRACE_REWRITE_MATCH
#define KC_TRACE_REWRITE_MATCH(VIEW,FILE,LINE,NODE)
#endif
#ifndef KC_TRACE_REWRITE_RESULT
#define KC_TRACE_REWRITE_RESULT(VIEW,FILE,LINE,NODE)
#endif

tFormula impl_tFormula_Compound::rewrite(rview kc_current_view_base)
{
    tFormula l_tFormula_1 =
	tFormula_1->rewrite(kc_current_view_base);
    tFormula l_tFormula_2 =
	tFormula_2->rewrite(kc_current_view_base);
    if ((l_tFormula_1 == tFormula_1) &&  (l_tFormula_2 == tFormula_2))
	return this;
    else {
	impl_tFormula_Compound* kc_result= Compound(l_tFormula_1, l_tFormula_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tFormula impl_tFormula_CompBound::rewrite(rview kc_current_view_base)
{
    return this;

}

tFormula impl_tFormula_StatePredicateFormula::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case singletemporal_enum: {
	    singletemporal_class& kc_current_view=static_cast<singletemporal_class&>(kc_current_view_base);
#line 553 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (KC_TRACE_PROVIDED((not phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_rewrite.k", 553, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 553, this);
#line 553 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 553 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(y);

#line  124 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",553,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 557 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (KC_TRACE_PROVIDED((not phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_rewrite.k", 557, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 557, this);
#line 557 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 557 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(Negation(y));

#line  136 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",557,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 532 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (KC_TRACE_PROVIDED((not phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_rewrite.k", 532, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 532, this);
#line 532 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 532 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(y);

#line  148 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",532,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 549 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (KC_TRACE_PROVIDED((not phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_rewrite.k", 549, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 549, this);
#line 549 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 549 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(Negation(y));

#line  160 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",549,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 540 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (KC_TRACE_PROVIDED((not phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_rewrite.k", 540, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 540, this);
#line 540 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 540 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(y);

#line  172 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",540,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 544 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (KC_TRACE_PROVIDED((not phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_rewrite.k", 544, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 544, this);
#line 544 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 544 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(Negation(y));

#line  184 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",544,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tFormula_StatePredicateFormula* kc_result= StatePredicateFormula(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_DisjunctionList::rewrite(rview kc_current_view_base)
{
    tDisjunction_list l_tDisjunction_list_1 =
	tDisjunction_list_1->rewrite(kc_current_view_base);
    if ((l_tDisjunction_list_1 == tDisjunction_list_1))
	return this;
    else {
	impl_tStatePredicate_DisjunctionList* kc_result= DisjunctionList(l_tDisjunction_list_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_ConjunctionList::rewrite(rview kc_current_view_base)
{
    tConjunction_list l_tConjunction_list_1 =
	tConjunction_list_1->rewrite(kc_current_view_base);
    if ((l_tConjunction_list_1 == tConjunction_list_1))
	return this;
    else {
	impl_tStatePredicate_ConjunctionList* kc_result= ConjunctionList(l_tConjunction_list_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_EX::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_EX* kc_result= EX(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_AX::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_AX* kc_result= AX(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_EG::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_EG* kc_result= EG(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_AG::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_AG* kc_result= AG(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_EF::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_EF* kc_result= EF(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_AF::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_AF* kc_result= AF(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_ER::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_ER* kc_result= ER(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_AR::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_AR* kc_result= AR(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_EU::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_EU* kc_result= EU(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_AU::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_AU* kc_result= AU(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_Release::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 168 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 168, this);
#line 168 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 168 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  383 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",168,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 177 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 177, this);
#line 177 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 177 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Always(x);

#line  395 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",177,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 198 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 198, this);
#line 198 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 198 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  407 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",198,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 201 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 201, this);
#line 201 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 201 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Always(x);

#line  419 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",201,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 165 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 165, this);
#line 165 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 165 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = y;

#line  431 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",165,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 180 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 180, this);
#line 180 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 180 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = y;

#line  443 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",180,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_Release* kc_result= Release(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_Until::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 417 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_Until) && (phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Elementary) && (l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_Elementary) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1)->tAtomicProposition_1 -> pred -> magicnumber == phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1 -> pred -> magicnumber), "Frontend/Parser/formula_rewrite.k", 417, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 417, this);
#line 417 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 417 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition x = phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1)->tAtomicProposition_1;
#line 417 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 417 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition z = phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1;
#line 417 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Until(y, a);

#line  484 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",417,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 387 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Elementary) && (l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_Elementary) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->pred->magicnumber==phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->pred->magicnumber), "Frontend/Parser/formula_rewrite.k", 387, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 387, this);
#line 387 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 387 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition x = phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1;
#line 387 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition y = phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1;
#line 387 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  500 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",387,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 390 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Elementary) && (l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_Elementary) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->pred->magicnumber== - phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->pred->magicnumber), "Frontend/Parser/formula_rewrite.k", 390, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 390, this);
#line 390 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition x = phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1;
#line 390 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_2;
#line 390 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition y = phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1;
#line 390 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Eventually(a);

#line  516 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",390,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 420 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Elementary) && (l_tStatePredicate_2->prod_sel() == sel_Until) && (phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_2)->tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_2)->tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_Elementary) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1 -> pred -> magicnumber == phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_2)->tStatePredicate_2)->tAtomicProposition_1 -> pred -> magicnumber), "Frontend/Parser/formula_rewrite.k", 420, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 420, this);
#line 420 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 420 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition x = phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1;
#line 420 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_2)->tStatePredicate_1;
#line 420 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition z = phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_2)->tStatePredicate_2)->tAtomicProposition_1;
#line 420 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Until(y, a);

#line  534 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",420,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 162 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 162, this);
#line 162 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 162 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Eventually(x);

#line  546 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",162,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 174 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 174, this);
#line 174 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 174 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  558 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",174,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 192 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 192, this);
#line 192 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 192 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  570 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",192,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 195 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 195, this);
#line 195 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 195 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Eventually(x);

#line  582 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",195,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 399 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 399, this);
#line 399 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate z = l_tStatePredicate_1;
#line 399 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 399 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 399 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Conjunction(y, z);

#line  598 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",399,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 402 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 402, this);
#line 402 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate z = l_tStatePredicate_1;
#line 402 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 402 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 402 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Conjunction(y, z);

#line  614 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",402,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 414 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Until) && (phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_Elementary) && (l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_Elementary) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2)->tAtomicProposition_1 -> pred -> magicnumber == phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1 -> pred -> magicnumber), "Frontend/Parser/formula_rewrite.k", 414, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 414, this);
#line 414 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 414 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 414 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition x = phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2)->tAtomicProposition_1;
#line 414 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition z = phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1;
#line 414 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Until(y, a);

#line  632 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",414,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 381 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_NextState) && (l_tStatePredicate_2->prod_sel() == sel_NextState)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 381, this);
#line 381 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 381 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_2)->tStatePredicate_1;
#line 381 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = NextState(Until(x, y));

#line  646 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",381,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 405 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 405, this);
#line 405 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate z = l_tStatePredicate_1;
#line 405 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 405 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 405 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Until(x, Conjunction(y, z));

#line  662 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",405,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 159 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 159, this);
#line 159 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 159 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = y;

#line  674 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",159,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 171 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 171, this);
#line 171 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 171 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = y;

#line  686 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",171,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 396 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_2->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 396, this);
#line 396 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 396 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 396 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate z = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_2)->tStatePredicate_1)->tStatePredicate_1;
#line 396 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = y;

#line  702 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",396,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 393 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_2->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 393, this);
#line 393 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 393 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 393 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate z = phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_2)->tStatePredicate_1;
#line 393 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = y;

#line  718 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",393,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_Until* kc_result= Until(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_NextState::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_NextState* kc_result= NextState(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_Eventually::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 129 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 129, this);
#line 129 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 129 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  764 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",129,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 132 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 132, this);
#line 132 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 132 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  776 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",132,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 186 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 186, this);
#line 186 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 186 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  788 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",186,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 360 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 360, this);
#line 360 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 360 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  800 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",360,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 345 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 345, this);
#line 345 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 345 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  812 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",345,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 408 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Until)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 408, this);
#line 408 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 408 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 408 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Eventually(y);

#line  826 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",408,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_Eventually* kc_result= Eventually(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_Always::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 135 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 135, this);
#line 135 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 135 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  859 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",135,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 138 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 138, this);
#line 138 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 138 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  871 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",138,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 189 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 189, this);
#line 189 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 189 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  883 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",189,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 363 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 363, this);
#line 363 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 363 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  895 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",363,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 411 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Until)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 411, this);
#line 411 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 411 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 411 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Conjunction(Always(Eventually(y)), Always(Conjunction(x, y)));

#line  909 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",411,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_Always* kc_result= Always(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_ExPath::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case ctloperators_enum: {
	    ctloperators_class& kc_current_view=static_cast<ctloperators_class&>(kc_current_view_base);
#line 611 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 611, this);
#line 611 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 611 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = EU(AtomicProposition(True()), x);

#line  942 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",611,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 613 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_NextState)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 613, this);
#line 613 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 613 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = EX(x);

#line  954 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",613,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 616 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 616, this);
#line 616 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 616 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Negation(AU(AtomicProposition(True()), Negation(x)));

#line  966 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",616,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 618 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Until)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 618, this);
#line 618 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 618 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 618 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = EU(x, y);

#line  980 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",618,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 621 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Release)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 621, this);
#line 621 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Release*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 621 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Release*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 621 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Negation(AU(Negation(x), Negation(y)));

#line  994 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",621,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case emptyquantifiers_enum: {
	    emptyquantifiers_class& kc_current_view=static_cast<emptyquantifiers_class&>(kc_current_view_base);
#line 496 "Frontend/Parser/formula_rewrite.k"
	    if ((KC_TRACE_PROVIDED((not l_tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_rewrite.k", 496, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 496, this);
#line 496 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 496 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1010 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",496,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 378 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 378, this);
#line 378 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 378 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1026 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",378,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 372 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 372, this);
#line 372 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 372 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1038 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",372,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 147 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 147, this);
#line 147 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 147 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1050 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",147,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 150 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 150, this);
#line 150 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 150 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1062 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",150,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 207 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 207, this);
#line 207 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 207 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1074 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",207,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 213 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 213, this);
#line 213 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 213 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1086 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",213,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 480 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Disjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 480, this);
#line 480 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = phylum_cast<const impl_tStatePredicate_Disjunction*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 480 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate b = phylum_cast<const impl_tStatePredicate_Disjunction*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2;
#line 480 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Disjunction(ExPath(Eventually(a)), ExPath(Eventually(b)));

#line  1100 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",480,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 486 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_NextState) && (phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Disjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 486, this);
#line 486 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = phylum_cast<const impl_tStatePredicate_Disjunction*>(phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 486 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate b = phylum_cast<const impl_tStatePredicate_Disjunction*>(phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2;
#line 486 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Disjunction(ExPath(NextState(a)), ExPath(NextState(b)));

#line  1114 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",486,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 354 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AllPath)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 354, this);
#line 354 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 354 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1126 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",354,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 357 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_ExPath)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 357, this);
#line 357 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 357 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1138 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",357,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 465 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Disjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 465, this);
#line 465 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 465 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 465 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Disjunction(ExPath(x), ExPath(y));

#line  1152 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",465,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_ExPath* kc_result= ExPath(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_AllPath::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case ctloperators_enum: {
	    ctloperators_class& kc_current_view=static_cast<ctloperators_class&>(kc_current_view_base);
#line 624 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 624, this);
#line 624 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 624 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AU(AtomicProposition(True()), x);

#line  1185 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",624,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 626 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_NextState)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 626, this);
#line 626 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 626 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AX(x);

#line  1197 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",626,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 629 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 629, this);
#line 629 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 629 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Negation(EU(AtomicProposition(True()), Negation(x)));

#line  1209 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",629,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 631 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Until)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 631, this);
#line 631 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 631 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 631 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AU(x, y);

#line  1223 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",631,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 634 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Release)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 634, this);
#line 634 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Release*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 634 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Release*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 634 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Negation(EU(Negation(x), Negation(y)));

#line  1237 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",634,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case emptyquantifiers_enum: {
	    emptyquantifiers_class& kc_current_view=static_cast<emptyquantifiers_class&>(kc_current_view_base);
#line 497 "Frontend/Parser/formula_rewrite.k"
	    if ((KC_TRACE_PROVIDED((not l_tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_rewrite.k", 497, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 497, this);
#line 497 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 497 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1253 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",497,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 375 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 375, this);
#line 375 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 375 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1269 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",375,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 366 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 366, this);
#line 366 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 366 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1281 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",366,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 369 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 369, this);
#line 369 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 369 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1293 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",369,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 153 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 153, this);
#line 153 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 153 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1305 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",153,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 156 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 156, this);
#line 156 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 156 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1317 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",156,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 204 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 204, this);
#line 204 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 204 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1329 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",204,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 210 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 210, this);
#line 210 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 210 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1341 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",210,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 477 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Conjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 477, this);
#line 477 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = phylum_cast<const impl_tStatePredicate_Conjunction*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 477 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate b = phylum_cast<const impl_tStatePredicate_Conjunction*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2;
#line 477 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Conjunction(AllPath(Always(a)), AllPath(Always(b)));

#line  1355 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",477,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 483 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_NextState) && (phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Conjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 483, this);
#line 483 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = phylum_cast<const impl_tStatePredicate_Conjunction*>(phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 483 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate b = phylum_cast<const impl_tStatePredicate_Conjunction*>(phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2;
#line 483 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Conjunction(AllPath(NextState(a)), AllPath(NextState(b)));

#line  1369 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",483,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 348 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AllPath)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 348, this);
#line 348 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 348 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1381 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",348,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 351 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_ExPath)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 351, this);
#line 351 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 351 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1393 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",351,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 468 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Conjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 468, this);
#line 468 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 468 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 468 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Conjunction(AllPath(x), AllPath(y));

#line  1407 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",468,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_AllPath* kc_result= AllPath(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_Equivalence::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case goodbye_doublearrows_enum: {
	    goodbye_doublearrows_class& kc_current_view=static_cast<goodbye_doublearrows_class&>(kc_current_view_base);
#line 63 "Frontend/Parser/formula_rewrite.k"
	    { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 63, this);
#line 63 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 63 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 64 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Conjunction(Disjunction(x, Negation(y)), Disjunction(Negation(x), y));

#line  1444 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",64,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    }
	}
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_Equivalence* kc_result= Equivalence(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_Implication::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case goodbye_singlearrows_enum: {
	    goodbye_singlearrows_class& kc_current_view=static_cast<goodbye_singlearrows_class&>(kc_current_view_base);
#line 69 "Frontend/Parser/formula_rewrite.k"
	    { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 69, this);
#line 69 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 69 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 69 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Disjunction(Negation(x), y);

#line  1479 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",69,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    }
	}
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_Implication* kc_result= Implication(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_ExclusiveDisjunction::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case goodbye_xor_enum: {
	    goodbye_xor_class& kc_current_view=static_cast<goodbye_xor_class&>(kc_current_view_base);
#line 74 "Frontend/Parser/formula_rewrite.k"
	    { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 74, this);
#line 74 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 74 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 74 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Disjunction(Conjunction(x, Negation(y)), Conjunction(Negation(x), y));

#line  1514 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",74,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    }
	}
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_ExclusiveDisjunction* kc_result= ExclusiveDisjunction(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_Disjunction::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case booleanlists_enum: {
	    booleanlists_class& kc_current_view=static_cast<booleanlists_class&>(kc_current_view_base);
#line 596 "Frontend/Parser/formula_rewrite.k"
	    { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 596, this);
#line 596 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 596 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 596 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = DisjunctionList(ConstDisjunction_list(x, ConstDisjunction_list(y, NiltDisjunction_list())));

#line  1549 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",596,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    }
	}
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 426 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Elementary) && (l_tStatePredicate_2->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Elementary) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->pred->magicnumber == phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1 -> pred->magicnumber), "Frontend/Parser/formula_rewrite.k", 426, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 426, this);
#line 426 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_1;
#line 426 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition x = phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1;
#line 426 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition z = phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1;
#line 426 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = y;

#line  1568 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",426,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 432 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Elementary) && (l_tStatePredicate_2->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Elementary) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->pred->magicnumber == phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1 -> pred->magicnumber), "Frontend/Parser/formula_rewrite.k", 432, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 432, this);
#line 432 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition x = phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1;
#line 432 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 432 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition z = phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1;
#line 432 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = y;

#line  1584 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",432,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 235 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock) && (l_tStatePredicate_2->prod_sel() == sel_Disjunction) && (phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 235, this);
#line 235 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(True());

#line  1594 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",235,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 236 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock) && (l_tStatePredicate_2->prod_sel() == sel_Disjunction) && (phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 236, this);
#line 236 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(True());

#line  1604 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",236,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 237 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock) && (l_tStatePredicate_2->prod_sel() == sel_Disjunction) && (phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 237, this);
#line 237 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 237 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1616 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",237,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 238 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock) && (l_tStatePredicate_2->prod_sel() == sel_Disjunction) && (phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 238, this);
#line 238 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 238 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1628 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",238,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 225 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock) && (l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 225, this);
#line 225 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(True());

#line  1638 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",225,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 226 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock) && (l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 226, this);
#line 226 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(True());

#line  1648 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",226,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 227 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock) && (l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 227, this);
#line 227 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 227 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1660 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",227,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 228 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock) && (l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 228, this);
#line 228 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 228 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1672 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",228,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 121 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 121, this);
#line 121 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_2;
#line 121 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1684 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",121,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 123 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 123, this);
#line 123 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate t = l_tStatePredicate_1;
#line 123 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = t;

#line  1696 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",123,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 451 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Eventually) && (l_tStatePredicate_2->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 451, this);
#line 451 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 451 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_2)->tStatePredicate_1;
#line 451 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Eventually(Disjunction(x, y));

#line  1710 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",451,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 460 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_NextState) && (l_tStatePredicate_2->prod_sel() == sel_NextState)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 460, this);
#line 460 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 460 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_2)->tStatePredicate_1;
#line 460 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = NextState(Disjunction(x, y));

#line  1724 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",460,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 252 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Disjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 252, this);
#line 252 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 252 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 252 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate z = l_tStatePredicate_2;
#line 252 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Disjunction(x, Disjunction(y, z));

#line  1740 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",252,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 120 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 120, this);
#line 120 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 120 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1752 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",120,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 122 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 122, this);
#line 122 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate t = l_tStatePredicate_2;
#line 122 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = t;

#line  1764 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",122,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_Disjunction* kc_result= Disjunction(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_Conjunction::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case booleanlists_enum: {
	    booleanlists_class& kc_current_view=static_cast<booleanlists_class&>(kc_current_view_base);
#line 592 "Frontend/Parser/formula_rewrite.k"
	    { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 592, this);
#line 592 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 592 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 592 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = ConjunctionList(ConstConjunction_list(x, ConstConjunction_list(y, NiltConjunction_list())));

#line  1801 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",592,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    }
	}
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 423 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Elementary) && (l_tStatePredicate_2->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Elementary) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->pred->magicnumber == phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1 -> pred->magicnumber), "Frontend/Parser/formula_rewrite.k", 423, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 423, this);
#line 423 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition x = phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1;
#line 423 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 423 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition z = phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1;
#line 423 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = y;

#line  1820 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",423,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 429 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Elementary) && (l_tStatePredicate_2->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Elementary) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->pred->magicnumber == phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1 -> pred->magicnumber), "Frontend/Parser/formula_rewrite.k", 429, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 429, this);
#line 429 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_1;
#line 429 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition x = phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1;
#line 429 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition z = phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1;
#line 429 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = y;

#line  1836 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",429,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 240 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock) && (l_tStatePredicate_2->prod_sel() == sel_Conjunction) && (phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 240, this);
#line 240 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(False());

#line  1846 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",240,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 241 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock) && (l_tStatePredicate_2->prod_sel() == sel_Conjunction) && (phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 241, this);
#line 241 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(False());

#line  1856 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",241,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 242 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock) && (l_tStatePredicate_2->prod_sel() == sel_Conjunction) && (phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 242, this);
#line 242 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 242 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1868 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",242,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 243 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock) && (l_tStatePredicate_2->prod_sel() == sel_Conjunction) && (phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 243, this);
#line 243 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 243 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1880 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",243,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 230 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock) && (l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 230, this);
#line 230 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(False());

#line  1890 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",230,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 231 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock) && (l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 231, this);
#line 231 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(False());

#line  1900 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",231,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 232 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock) && (l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 232, this);
#line 232 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 232 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1912 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",232,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 233 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock) && (l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 233, this);
#line 233 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 233 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1924 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",233,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 115 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 115, this);
#line 115 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_2;
#line 115 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1936 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",115,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 117 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 117, this);
#line 117 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate f = l_tStatePredicate_1;
#line 117 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = f;

#line  1948 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",117,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 454 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Always) && (l_tStatePredicate_2->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 454, this);
#line 454 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 454 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_2)->tStatePredicate_1;
#line 454 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Always(Conjunction(x, y));

#line  1962 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",454,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 457 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_NextState) && (l_tStatePredicate_2->prod_sel() == sel_NextState)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 457, this);
#line 457 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 457 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_2)->tStatePredicate_1;
#line 457 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = NextState(Conjunction(x, y));

#line  1976 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",457,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 249 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Conjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 249, this);
#line 249 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 249 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 249 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate z = l_tStatePredicate_2;
#line 249 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Conjunction(x, Conjunction(y, z));

#line  1992 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",249,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 114 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 114, this);
#line 114 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 114 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  2004 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",114,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 116 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 116, this);
#line 116 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate f = l_tStatePredicate_2;
#line 116 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = f;

#line  2016 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",116,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_Conjunction* kc_result= Conjunction(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_Negation::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case simpleneg_enum: {
	    simpleneg_class& kc_current_view=static_cast<simpleneg_class&>(kc_current_view_base);
#line 587 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NNegation) && (phylum_cast<const impl_tAtomicProposition_NNegation*>(phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1)->tAtomicProposition_1->prod_sel() == sel_Elementary)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 587, this);
#line 587 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition x = phylum_cast<const impl_tAtomicProposition_NNegation*>(phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1)->tAtomicProposition_1;
#line 587 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(x);

#line  2049 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",587,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 569 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 569, this);
#line 569 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(False());

#line  2059 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",569,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 572 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 572, this);
#line 572 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(True());

#line  2069 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",572,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 575 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 575, this);
#line 575 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(NoDeadlock());

#line  2079 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",575,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 578 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 578, this);
#line 578 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(Deadlock());

#line  2089 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",578,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 586 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Elementary)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 586, this);
#line 586 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition x = phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1;
#line 586 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(NNegation(x));

#line  2101 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",586,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 561 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Negation)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 561, this);
#line 561 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Negation*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 561 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  2113 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",561,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 563 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Conjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 563, this);
#line 563 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 563 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 563 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Disjunction(Negation(x), Negation(y));

#line  2127 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",563,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 566 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Disjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 566, this);
#line 566 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 566 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 566 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Conjunction(Negation(x), Negation(y));

#line  2141 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",566,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case singletemporal_enum: {
	    singletemporal_class& kc_current_view=static_cast<singletemporal_class&>(kc_current_view_base);
#line 529 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_Negation)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 529, this);
#line 529 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Negation*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 529 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = y;

#line  2157 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",529,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 298 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NNegation) && (phylum_cast<const impl_tAtomicProposition_NNegation*>(phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1)->tAtomicProposition_1->prod_sel() == sel_Elementary)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 298, this);
#line 298 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition x = phylum_cast<const impl_tAtomicProposition_NNegation*>(phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1)->tAtomicProposition_1;
#line 298 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(x);

#line  2173 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",298,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 277 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 277, this);
#line 277 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(False());

#line  2183 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",277,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 280 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 280, this);
#line 280 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(True());

#line  2193 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",280,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 283 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 283, this);
#line 283 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(NoDeadlock());

#line  2203 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",283,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 286 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 286, this);
#line 286 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(Deadlock());

#line  2213 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",286,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 295 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Elementary)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 295, this);
#line 295 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition x = phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1;
#line 295 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(NNegation(x));

#line  2225 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",295,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 310 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Negation)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 310, this);
#line 310 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Negation*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 310 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  2237 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",310,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 313 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Conjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 313, this);
#line 313 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 313 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 313 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Disjunction(Negation(x), Negation(y));

#line  2251 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",313,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 316 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Disjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 316, this);
#line 316 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 316 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 316 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Conjunction(Negation(x), Negation(y));

#line  2265 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",316,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 321 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AllPath)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 321, this);
#line 321 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 321 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = ExPath(Negation(x));

#line  2277 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",321,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 324 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_ExPath)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 324, this);
#line 324 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 324 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AllPath(Negation(x));

#line  2289 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",324,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 327 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 327, this);
#line 327 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 327 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Eventually(Negation(x));

#line  2301 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",327,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 330 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 330, this);
#line 330 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 330 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Always(Negation(x));

#line  2313 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",330,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 333 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_NextState)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 333, this);
#line 333 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 333 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = NextState(Negation(x));

#line  2325 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",333,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 336 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Until)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 336, this);
#line 336 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 336 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 336 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Release(Negation(x), Negation(y));

#line  2339 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",336,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 339 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Release)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 339, this);
#line 339 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Release*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 339 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Release*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 339 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Until(Negation(x), Negation(y));

#line  2353 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",339,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_Negation* kc_result= Negation(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_AtomicProposition::rewrite(rview kc_current_view_base)
{
    tAtomicProposition l_tAtomicProposition_1 =
	tAtomicProposition_1->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 101 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tAtomicProposition_1->prod_sel() == sel_NNegation) && (phylum_cast<const impl_tAtomicProposition_NNegation*>(l_tAtomicProposition_1)->tAtomicProposition_1->prod_sel() == sel_Elementary) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tAtomicProposition_NNegation*>(l_tAtomicProposition_1)->tAtomicProposition_1->pred->magicnumber == MAGIC_NUMBER_FALSE), "Frontend/Parser/formula_rewrite.k", 101, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 101, this);
#line 101 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate f = (((l_tAtomicProposition_1 == tAtomicProposition_1)) ? this : AtomicProposition(l_tAtomicProposition_1));
#line 101 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition x = phylum_cast<const impl_tAtomicProposition_NNegation*>(l_tAtomicProposition_1)->tAtomicProposition_1;
#line 101 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(True());

#line  2388 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",101,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 103 "Frontend/Parser/formula_rewrite.k"
		if ((l_tAtomicProposition_1->prod_sel() == sel_NNegation) && (phylum_cast<const impl_tAtomicProposition_NNegation*>(l_tAtomicProposition_1)->tAtomicProposition_1->prod_sel() == sel_Elementary) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tAtomicProposition_NNegation*>(l_tAtomicProposition_1)->tAtomicProposition_1->pred->magicnumber == MAGIC_NUMBER_TRUE), "Frontend/Parser/formula_rewrite.k", 103, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 103, this);
#line 103 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate f = (((l_tAtomicProposition_1 == tAtomicProposition_1)) ? this : AtomicProposition(l_tAtomicProposition_1));
#line 103 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition x = phylum_cast<const impl_tAtomicProposition_NNegation*>(l_tAtomicProposition_1)->tAtomicProposition_1;
#line 103 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(False());

#line  2402 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",103,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 93 "Frontend/Parser/formula_rewrite.k"
		if ((l_tAtomicProposition_1->prod_sel() == sel_Elementary) && (KC_TRACE_PROVIDED(((((l_tAtomicProposition_1 == tAtomicProposition_1)) ? this : AtomicProposition(l_tAtomicProposition_1))->shape == AT_TRUE), "Frontend/Parser/formula_rewrite.k", 93, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 93, this);
#line 93 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate f = (((l_tAtomicProposition_1 == tAtomicProposition_1)) ? this : AtomicProposition(l_tAtomicProposition_1));
#line 93 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(True());

#line  2414 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",93,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 95 "Frontend/Parser/formula_rewrite.k"
		if ((l_tAtomicProposition_1->prod_sel() == sel_Elementary) && (KC_TRACE_PROVIDED(((((l_tAtomicProposition_1 == tAtomicProposition_1)) ? this : AtomicProposition(l_tAtomicProposition_1))->shape == AT_FALSE), "Frontend/Parser/formula_rewrite.k", 95, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 95, this);
#line 95 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate f = (((l_tAtomicProposition_1 == tAtomicProposition_1)) ? this : AtomicProposition(l_tAtomicProposition_1));
#line 95 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(False());

#line  2426 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",95,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 97 "Frontend/Parser/formula_rewrite.k"
		if ((l_tAtomicProposition_1->prod_sel() == sel_Elementary) && (KC_TRACE_PROVIDED((l_tAtomicProposition_1->pred->magicnumber == MAGIC_NUMBER_FALSE), "Frontend/Parser/formula_rewrite.k", 97, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 97, this);
#line 97 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate f = (((l_tAtomicProposition_1 == tAtomicProposition_1)) ? this : AtomicProposition(l_tAtomicProposition_1));
#line 97 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition x = l_tAtomicProposition_1;
#line 97 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(False());

#line  2440 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",97,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 99 "Frontend/Parser/formula_rewrite.k"
		if ((l_tAtomicProposition_1->prod_sel() == sel_Elementary) && (KC_TRACE_PROVIDED((l_tAtomicProposition_1->pred->magicnumber == MAGIC_NUMBER_TRUE), "Frontend/Parser/formula_rewrite.k", 99, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 99, this);
#line 99 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate f = (((l_tAtomicProposition_1 == tAtomicProposition_1)) ? this : AtomicProposition(l_tAtomicProposition_1));
#line 99 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition x = l_tAtomicProposition_1;
#line 99 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(True());

#line  2454 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",99,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 105 "Frontend/Parser/formula_rewrite.k"
		if ((l_tAtomicProposition_1->prod_sel() == sel_Elementary) && (KC_TRACE_PROVIDED((((((l_tAtomicProposition_1 == tAtomicProposition_1)) ? this : AtomicProposition(l_tAtomicProposition_1))->shape == AT_DL) && ((DeadlockPredicate*)((((l_tAtomicProposition_1 == tAtomicProposition_1)) ? this : AtomicProposition(l_tAtomicProposition_1))->formula))->sign), "Frontend/Parser/formula_rewrite.k", 105, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 105, this);
#line 105 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate f = (((l_tAtomicProposition_1 == tAtomicProposition_1)) ? this : AtomicProposition(l_tAtomicProposition_1));
#line 105 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(Deadlock());

#line  2466 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",105,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 107 "Frontend/Parser/formula_rewrite.k"
		if ((l_tAtomicProposition_1->prod_sel() == sel_Elementary) && (KC_TRACE_PROVIDED((((((l_tAtomicProposition_1 == tAtomicProposition_1)) ? this : AtomicProposition(l_tAtomicProposition_1))->shape == AT_DL) && !(((DeadlockPredicate*)((((l_tAtomicProposition_1 == tAtomicProposition_1)) ? this : AtomicProposition(l_tAtomicProposition_1))->formula))->sign)), "Frontend/Parser/formula_rewrite.k", 107, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 107, this);
#line 107 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate f = (((l_tAtomicProposition_1 == tAtomicProposition_1)) ? this : AtomicProposition(l_tAtomicProposition_1));
#line 107 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(NoDeadlock());

#line  2478 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",107,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 109 "Frontend/Parser/formula_rewrite.k"
		if ((l_tAtomicProposition_1->prod_sel() == sel_Elementary) && (KC_TRACE_PROVIDED((((((l_tAtomicProposition_1 == tAtomicProposition_1)) ? this : AtomicProposition(l_tAtomicProposition_1))->shape == AT_COMP) && (((AtomicStatePredicate*)((((l_tAtomicProposition_1 == tAtomicProposition_1)) ? this : AtomicProposition(l_tAtomicProposition_1))->formula))->cardPos == 0) && (((AtomicStatePredicate*)((((l_tAtomicProposition_1 == tAtomicProposition_1)) ? this : AtomicProposition(l_tAtomicProposition_1))->formula))->threshold >= 0)), "Frontend/Parser/formula_rewrite.k", 109, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 109, this);
#line 109 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate f = (((l_tAtomicProposition_1 == tAtomicProposition_1)) ? this : AtomicProposition(l_tAtomicProposition_1));
#line 109 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(True());

#line  2490 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",109,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 111 "Frontend/Parser/formula_rewrite.k"
		if ((l_tAtomicProposition_1->prod_sel() == sel_Elementary) && (KC_TRACE_PROVIDED((((((l_tAtomicProposition_1 == tAtomicProposition_1)) ? this : AtomicProposition(l_tAtomicProposition_1))->shape == AT_COMP) && (((AtomicStatePredicate*)((((l_tAtomicProposition_1 == tAtomicProposition_1)) ? this : AtomicProposition(l_tAtomicProposition_1))->formula))->cardNeg == 0) && (((AtomicStatePredicate*)((((l_tAtomicProposition_1 == tAtomicProposition_1)) ? this : AtomicProposition(l_tAtomicProposition_1))->formula))->threshold < 0)), "Frontend/Parser/formula_rewrite.k", 111, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 111, this);
#line 111 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate f = (((l_tAtomicProposition_1 == tAtomicProposition_1)) ? this : AtomicProposition(l_tAtomicProposition_1));
#line 111 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(False());

#line  2502 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",111,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tAtomicProposition_1 == tAtomicProposition_1))
	return this;
    else {
	impl_tStatePredicate_AtomicProposition* kc_result= AtomicProposition(l_tAtomicProposition_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tConjunction_list impl_tConjunction_list::rewrite(rview kc_current_view_base)
{
    if (is_nil()) {
	return this;
    } else { // not Nil, Cons
	tStatePredicate l_tStatePredicate_1 =
	    tStatePredicate_1->rewrite(kc_current_view_base);
	tConjunction_list l_tConjunction_list_1 =
	    tConjunction_list_1->rewrite(kc_current_view_base);
	switch(kc_current_view_base) {
	    case booleanlists_enum: {
		booleanlists_class& kc_current_view=static_cast<booleanlists_class&>(kc_current_view_base);
#line 593 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_ConjunctionList)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 593, this);
#line 593 "Frontend/Parser/formula_rewrite.k"
		    const tConjunction_list x = phylum_cast<const impl_tStatePredicate_ConjunctionList*>(l_tStatePredicate_1)->tConjunction_list_1;
#line 593 "Frontend/Parser/formula_rewrite.k"
		    const tConjunction_list y = l_tConjunction_list_1;
#line 593 "Frontend/Parser/formula_rewrite.k"
		    tConjunction_list kc_result = concat(x, y);

#line  2542 "ast-system-rk.cc"
		    KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",593,kc_result);
		    return (const_cast<const impl_tConjunction_list*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

		} else
			goto kc_rewrite_default;
	    }
	    kc_rewrite_default:
	    default:;
	}
	if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tConjunction_list_1 == tConjunction_list_1))
	    return this;
	else {
	    impl_tConjunction_list* kc_result= ConstConjunction_list(l_tStatePredicate_1, l_tConjunction_list_1);
	    kc_result->rewrite_members(this);
	    return kc_result;
	}   }
}

tDisjunction_list impl_tDisjunction_list::rewrite(rview kc_current_view_base)
{
    if (is_nil()) {
	return this;
    } else { // not Nil, Cons
	tStatePredicate l_tStatePredicate_1 =
	    tStatePredicate_1->rewrite(kc_current_view_base);
	tDisjunction_list l_tDisjunction_list_1 =
	    tDisjunction_list_1->rewrite(kc_current_view_base);
	switch(kc_current_view_base) {
	    case booleanlists_enum: {
		booleanlists_class& kc_current_view=static_cast<booleanlists_class&>(kc_current_view_base);
#line 597 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_DisjunctionList)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 597, this);
#line 597 "Frontend/Parser/formula_rewrite.k"
		    const tDisjunction_list x = phylum_cast<const impl_tStatePredicate_DisjunctionList*>(l_tStatePredicate_1)->tDisjunction_list_1;
#line 597 "Frontend/Parser/formula_rewrite.k"
		    const tDisjunction_list y = l_tDisjunction_list_1;
#line 597 "Frontend/Parser/formula_rewrite.k"
		    tDisjunction_list kc_result = concat(x, y);

#line  2582 "ast-system-rk.cc"
		    KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",597,kc_result);
		    return (const_cast<const impl_tDisjunction_list*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

		} else
			goto kc_rewrite_default;
	    }
	    kc_rewrite_default:
	    default:;
	}
	if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tDisjunction_list_1 == tDisjunction_list_1))
	    return this;
	else {
	    impl_tDisjunction_list* kc_result= ConstDisjunction_list(l_tStatePredicate_1, l_tDisjunction_list_1);
	    kc_result->rewrite_members(this);
	    return kc_result;
	}   }
}

tAtomicProposition impl_tAtomicProposition_Deadlock::rewrite(rview kc_current_view_base)
{
    return this;

}

tAtomicProposition impl_tAtomicProposition_NoDeadlock::rewrite(rview kc_current_view_base)
{
    return this;

}

tAtomicProposition impl_tAtomicProposition_False::rewrite(rview kc_current_view_base)
{
    return this;

}

tAtomicProposition impl_tAtomicProposition_True::rewrite(rview kc_current_view_base)
{
    return this;

}

tAtomicProposition impl_tAtomicProposition_NNegation::rewrite(rview kc_current_view_base)
{
    tAtomicProposition l_tAtomicProposition_1 =
	tAtomicProposition_1->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 302 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 302, this);
#line 302 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = NoDeadlock();

#line  2637 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",302,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 303 "Frontend/Parser/formula_rewrite.k"
		if ((l_tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 303, this);
#line 303 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = Deadlock();

#line  2647 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",303,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 304 "Frontend/Parser/formula_rewrite.k"
		if ((l_tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 304, this);
#line 304 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = False();

#line  2657 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",304,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 305 "Frontend/Parser/formula_rewrite.k"
		if ((l_tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 305, this);
#line 305 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = True();

#line  2667 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",305,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 306 "Frontend/Parser/formula_rewrite.k"
		if ((l_tAtomicProposition_1->prod_sel() == sel_NNegation)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 306, this);
#line 306 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition x = phylum_cast<const impl_tAtomicProposition_NNegation*>(l_tAtomicProposition_1)->tAtomicProposition_1;
#line 306 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = x;

#line  2679 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",306,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tAtomicProposition_1 == tAtomicProposition_1))
	return this;
    else {
	impl_tAtomicProposition_NNegation* kc_result= NNegation(l_tAtomicProposition_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tAtomicProposition impl_tAtomicProposition_Elementary::rewrite(rview kc_current_view_base)
{
    return this;

}

tTerm impl_tTerm_Complex::rewrite(rview kc_current_view_base)
{
    return this;

}

tBuechiAutomata impl_tBuechiAutomata_BuechiNull::rewrite(rview kc_current_view_base)
{
    return this;

}

tBuechiAutomata impl_tBuechiAutomata_BuechiAutomaton::rewrite(rview kc_current_view_base)
{
    tBuechiRules l_tBuechiRules_1 =
	tBuechiRules_1->rewrite(kc_current_view_base);
    tAcceptingSet l_tAcceptingSet_1 =
	tAcceptingSet_1->rewrite(kc_current_view_base);
    if ((l_tBuechiRules_1 == tBuechiRules_1) &&  (l_tAcceptingSet_1 == tAcceptingSet_1))
	return this;
    else {
	impl_tBuechiAutomata_BuechiAutomaton* kc_result= BuechiAutomaton(l_tBuechiRules_1, l_tAcceptingSet_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tBuechiRules impl_tBuechiRules_BuechiRules::rewrite(rview kc_current_view_base)
{
    tBuechiRules l_tBuechiRules_1 =
	tBuechiRules_1->rewrite(kc_current_view_base);
    tBuechiRules l_tBuechiRules_2 =
	tBuechiRules_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case rbuechi_enum: {
	    rbuechi_class& kc_current_view=static_cast<rbuechi_class&>(kc_current_view_base);
#line 644 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tBuechiRules_1->prod_sel() == sel_EmptyBuechiRules)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 644, this);
#line 644 "Frontend/Parser/formula_rewrite.k"
		const tBuechiRules a = l_tBuechiRules_2;
#line 644 "Frontend/Parser/formula_rewrite.k"
		tBuechiRules kc_result = a;

#line  2747 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",644,kc_result);
		return (const_cast<const impl_tBuechiRules*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 643 "Frontend/Parser/formula_rewrite.k"
		if ((l_tBuechiRules_2->prod_sel() == sel_EmptyBuechiRules)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 643, this);
#line 643 "Frontend/Parser/formula_rewrite.k"
		const tBuechiRules a = l_tBuechiRules_1;
#line 643 "Frontend/Parser/formula_rewrite.k"
		tBuechiRules kc_result = a;

#line  2759 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",643,kc_result);
		return (const_cast<const impl_tBuechiRules*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tBuechiRules_1 == tBuechiRules_1) &&  (l_tBuechiRules_2 == tBuechiRules_2))
	return this;
    else {
	impl_tBuechiRules_BuechiRules* kc_result= BuechiRules(l_tBuechiRules_1, l_tBuechiRules_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tBuechiRules impl_tBuechiRules_ExpandedBuechiRule::rewrite(rview kc_current_view_base)
{
    integer l_integer_1 =
	integer_1->rewrite(kc_current_view_base);
    tFormula l_tFormula_1 =
	tFormula_1->rewrite(kc_current_view_base);
    integer l_integer_2 =
	integer_2->rewrite(kc_current_view_base);
    if ((l_integer_1 == integer_1) &&  (l_tFormula_1 == tFormula_1) &&  (l_integer_2 == integer_2))
	return this;
    else {
	impl_tBuechiRules_ExpandedBuechiRule* kc_result= ExpandedBuechiRule(l_integer_1, l_tFormula_1, l_integer_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tBuechiRules impl_tBuechiRules_BuechiRule::rewrite(rview kc_current_view_base)
{
    integer l_integer_1 =
	integer_1->rewrite(kc_current_view_base);
    tTransitionRules l_tTransitionRules_1 =
	tTransitionRules_1->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case rbuechi_enum: {
	    rbuechi_class& kc_current_view=static_cast<rbuechi_class&>(kc_current_view_base);
#line 640 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tTransitionRules_1->prod_sel() == sel_TransitionRules)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 640, this);
#line 640 "Frontend/Parser/formula_rewrite.k"
		const integer from = l_integer_1;
#line 640 "Frontend/Parser/formula_rewrite.k"
		const tTransitionRules lrules = phylum_cast<const impl_tTransitionRules_TransitionRules*>(l_tTransitionRules_1)->tTransitionRules_1;
#line 640 "Frontend/Parser/formula_rewrite.k"
		const tTransitionRules rrules = phylum_cast<const impl_tTransitionRules_TransitionRules*>(l_tTransitionRules_1)->tTransitionRules_2;
#line 640 "Frontend/Parser/formula_rewrite.k"
		tBuechiRules kc_result = BuechiRules(BuechiRule(from, lrules), BuechiRule(from, rrules));

#line  2815 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",640,kc_result);
		return (const_cast<const impl_tBuechiRules*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 641 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTransitionRules_1->prod_sel() == sel_TransitionRule)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 641, this);
#line 641 "Frontend/Parser/formula_rewrite.k"
		const integer from = l_integer_1;
#line 641 "Frontend/Parser/formula_rewrite.k"
		const tFormula formula = phylum_cast<const impl_tTransitionRules_TransitionRule*>(l_tTransitionRules_1)->tFormula_1;
#line 641 "Frontend/Parser/formula_rewrite.k"
		const integer to = phylum_cast<const impl_tTransitionRules_TransitionRule*>(l_tTransitionRules_1)->integer_1;
#line 641 "Frontend/Parser/formula_rewrite.k"
		tBuechiRules kc_result = ExpandedBuechiRule(from, formula, to);

#line  2831 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",641,kc_result);
		return (const_cast<const impl_tBuechiRules*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 642 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTransitionRules_1->prod_sel() == sel_EmptyTransitionRules)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 642, this);
#line 642 "Frontend/Parser/formula_rewrite.k"
		tBuechiRules kc_result = EmptyBuechiRules();

#line  2841 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",642,kc_result);
		return (const_cast<const impl_tBuechiRules*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_integer_1 == integer_1) &&  (l_tTransitionRules_1 == tTransitionRules_1))
	return this;
    else {
	impl_tBuechiRules_BuechiRule* kc_result= BuechiRule(l_integer_1, l_tTransitionRules_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tBuechiRules impl_tBuechiRules_EmptyBuechiRules::rewrite(rview kc_current_view_base)
{
    return this;

}

tTransitionRules impl_tTransitionRules_TransitionRules::rewrite(rview kc_current_view_base)
{
    tTransitionRules l_tTransitionRules_1 =
	tTransitionRules_1->rewrite(kc_current_view_base);
    tTransitionRules l_tTransitionRules_2 =
	tTransitionRules_2->rewrite(kc_current_view_base);
    if ((l_tTransitionRules_1 == tTransitionRules_1) &&  (l_tTransitionRules_2 == tTransitionRules_2))
	return this;
    else {
	impl_tTransitionRules_TransitionRules* kc_result= TransitionRules(l_tTransitionRules_1, l_tTransitionRules_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tTransitionRules impl_tTransitionRules_TransitionRule::rewrite(rview kc_current_view_base)
{
    tFormula l_tFormula_1 =
	tFormula_1->rewrite(kc_current_view_base);
    integer l_integer_1 =
	integer_1->rewrite(kc_current_view_base);
    if ((l_tFormula_1 == tFormula_1) &&  (l_integer_1 == integer_1))
	return this;
    else {
	impl_tTransitionRules_TransitionRule* kc_result= TransitionRule(l_tFormula_1, l_integer_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tTransitionRules impl_tTransitionRules_EmptyTransitionRules::rewrite(rview kc_current_view_base)
{
    return this;

}

tAcceptingSet impl_tAcceptingSet_AcceptingSet::rewrite(rview kc_current_view_base)
{
    tAcceptingSet l_tAcceptingSet_1 =
	tAcceptingSet_1->rewrite(kc_current_view_base);
    tAcceptingSet l_tAcceptingSet_2 =
	tAcceptingSet_2->rewrite(kc_current_view_base);
    if ((l_tAcceptingSet_1 == tAcceptingSet_1) &&  (l_tAcceptingSet_2 == tAcceptingSet_2))
	return this;
    else {
	impl_tAcceptingSet_AcceptingSet* kc_result= AcceptingSet(l_tAcceptingSet_1, l_tAcceptingSet_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tAcceptingSet impl_tAcceptingSet_AcceptingState::rewrite(rview kc_current_view_base)
{
    integer l_integer_1 =
	integer_1->rewrite(kc_current_view_base);
    if ((l_integer_1 == integer_1))
	return this;
    else {
	impl_tAcceptingSet_AcceptingState* kc_result= AcceptingState(l_integer_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tAcceptingSet impl_tAcceptingSet_EmptyAcceptingSet::rewrite(rview kc_current_view_base)
{
    return this;

}

net impl_net_Net::rewrite(rview kc_current_view_base)
{
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    definitionsList l_definitionsList_1 =
	definitionsList_1->rewrite(kc_current_view_base);
    placeblocklist l_placeblocklist_1 =
	placeblocklist_1->rewrite(kc_current_view_base);
    marking l_marking_1 =
	marking_1->rewrite(kc_current_view_base);
    transition l_transition_1 =
	transition_1->rewrite(kc_current_view_base);
    if ((l_casestring_1 == casestring_1) &&  (l_definitionsList_1 == definitionsList_1) &&  (l_placeblocklist_1 == placeblocklist_1) &&  (l_marking_1 == marking_1) &&  (l_transition_1 == transition_1))
	return this;
    else {
	impl_net_Net* kc_result= Net(l_casestring_1, l_definitionsList_1, l_placeblocklist_1, l_marking_1, l_transition_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

definitionsList impl_definitionsList_DefinitionsList::rewrite(rview kc_current_view_base)
{
    definitionsList l_definitionsList_1 =
	definitionsList_1->rewrite(kc_current_view_base);
    definitions l_definitions_1 =
	definitions_1->rewrite(kc_current_view_base);
    if ((l_definitionsList_1 == definitionsList_1) &&  (l_definitions_1 == definitions_1))
	return this;
    else {
	impl_definitionsList_DefinitionsList* kc_result= DefinitionsList(l_definitionsList_1, l_definitions_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

definitionsList impl_definitionsList_EmptyDefinitionsList::rewrite(rview kc_current_view_base)
{
    return this;

}

definitions impl_definitions_Function::rewrite(rview kc_current_view_base)
{
    type l_type_1 =
	type_1->rewrite(kc_current_view_base);
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    arrayList l_arrayList_1 =
	arrayList_1->rewrite(kc_current_view_base);
    functionParametersList l_functionParametersList_1 =
	functionParametersList_1->rewrite(kc_current_view_base);
    block l_block_1 =
	block_1->rewrite(kc_current_view_base);
    if ((l_type_1 == type_1) &&  (l_casestring_1 == casestring_1) &&  (l_arrayList_1 == arrayList_1) &&  (l_functionParametersList_1 == functionParametersList_1) &&  (l_block_1 == block_1))
	return this;
    else {
	impl_definitions_Function* kc_result= Function(l_type_1, l_casestring_1, l_arrayList_1, l_functionParametersList_1, l_block_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

definitions impl_definitions_Sort::rewrite(rview kc_current_view_base)
{
    type l_type_1 =
	type_1->rewrite(kc_current_view_base);
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    arrayList l_arrayList_1 =
	arrayList_1->rewrite(kc_current_view_base);
    if ((l_type_1 == type_1) &&  (l_casestring_1 == casestring_1) &&  (l_arrayList_1 == arrayList_1))
	return this;
    else {
	impl_definitions_Sort* kc_result= Sort(l_type_1, l_casestring_1, l_arrayList_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

definitions impl_definitions_Constant::rewrite(rview kc_current_view_base)
{
    type l_type_1 =
	type_1->rewrite(kc_current_view_base);
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    arrayList l_arrayList_1 =
	arrayList_1->rewrite(kc_current_view_base);
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_type_1 == type_1) &&  (l_casestring_1 == casestring_1) &&  (l_arrayList_1 == arrayList_1) &&  (l_expression_1 == expression_1))
	return this;
    else {
	impl_definitions_Constant* kc_result= Constant(l_type_1, l_casestring_1, l_arrayList_1, l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

type impl_type_TypeBlack::rewrite(rview kc_current_view_base)
{
    return this;

}

type impl_type_TypeArray::rewrite(rview kc_current_view_base)
{
    type l_type_1 =
	type_1->rewrite(kc_current_view_base);
    integer l_integer_1 =
	integer_1->rewrite(kc_current_view_base);
    if ((l_type_1 == type_1) &&  (l_integer_1 == integer_1))
	return this;
    else {
	impl_type_TypeArray* kc_result= TypeArray(l_type_1, l_integer_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

type impl_type_TypeMultiset::rewrite(rview kc_current_view_base)
{
    type l_type_1 =
	type_1->rewrite(kc_current_view_base);
    if ((l_type_1 == type_1))
	return this;
    else {
	impl_type_TypeMultiset* kc_result= TypeMultiset(l_type_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

type impl_type_TypeInt::rewrite(rview kc_current_view_base)
{
    return this;

}

type impl_type_TypeStruct::rewrite(rview kc_current_view_base)
{
    structTypeList l_structTypeList_1 =
	structTypeList_1->rewrite(kc_current_view_base);
    if ((l_structTypeList_1 == structTypeList_1))
	return this;
    else {
	impl_type_TypeStruct* kc_result= TypeStruct(l_structTypeList_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

type impl_type_TypeIntInterval::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2))
	return this;
    else {
	impl_type_TypeIntInterval* kc_result= TypeIntInterval(l_expression_1, l_expression_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

type impl_type_TypeIdent::rewrite(rview kc_current_view_base)
{
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    if ((l_casestring_1 == casestring_1))
	return this;
    else {
	impl_type_TypeIdent* kc_result= TypeIdent(l_casestring_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

type impl_type_TypeEnum::rewrite(rview kc_current_view_base)
{
    identList l_identList_1 =
	identList_1->rewrite(kc_current_view_base);
    if ((l_identList_1 == identList_1))
	return this;
    else {
	impl_type_TypeEnum* kc_result= TypeEnum(l_identList_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

type impl_type_TypeBool::rewrite(rview kc_current_view_base)
{
    return this;

}

optionalNumber impl_optionalNumber_OptNumber::rewrite(rview kc_current_view_base)
{
    integer l_integer_1 =
	integer_1->rewrite(kc_current_view_base);
    if ((l_integer_1 == integer_1))
	return this;
    else {
	impl_optionalNumber_OptNumber* kc_result= OptNumber(l_integer_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

optionalNumber impl_optionalNumber_EmptyOptNumber::rewrite(rview kc_current_view_base)
{
    return this;

}

identList impl_identList_IdentList::rewrite(rview kc_current_view_base)
{
    identList l_identList_1 =
	identList_1->rewrite(kc_current_view_base);
    idents l_idents_1 =
	idents_1->rewrite(kc_current_view_base);
    if ((l_identList_1 == identList_1) &&  (l_idents_1 == idents_1))
	return this;
    else {
	impl_identList_IdentList* kc_result= IdentList(l_identList_1, l_idents_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

identList impl_identList_EmptyIdentList::rewrite(rview kc_current_view_base)
{
    return this;

}

idents impl_idents_Idents::rewrite(rview kc_current_view_base)
{
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    optionalNumber l_optionalNumber_1 =
	optionalNumber_1->rewrite(kc_current_view_base);
    if ((l_casestring_1 == casestring_1) &&  (l_optionalNumber_1 == optionalNumber_1))
	return this;
    else {
	impl_idents_Idents* kc_result= Idents(l_casestring_1, l_optionalNumber_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

structTypeList impl_structTypeList_StructTypeList::rewrite(rview kc_current_view_base)
{
    structTypeList l_structTypeList_1 =
	structTypeList_1->rewrite(kc_current_view_base);
    structType l_structType_1 =
	structType_1->rewrite(kc_current_view_base);
    if ((l_structTypeList_1 == structTypeList_1) &&  (l_structType_1 == structType_1))
	return this;
    else {
	impl_structTypeList_StructTypeList* kc_result= StructTypeList(l_structTypeList_1, l_structType_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

structTypeList impl_structTypeList_EmptyStructTypeList::rewrite(rview kc_current_view_base)
{
    return this;

}

structType impl_structType_StructType::rewrite(rview kc_current_view_base)
{
    type l_type_1 =
	type_1->rewrite(kc_current_view_base);
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    arrayList l_arrayList_1 =
	arrayList_1->rewrite(kc_current_view_base);
    if ((l_type_1 == type_1) &&  (l_casestring_1 == casestring_1) &&  (l_arrayList_1 == arrayList_1))
	return this;
    else {
	impl_structType_StructType* kc_result= StructType(l_type_1, l_casestring_1, l_arrayList_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

varOrArray impl_varOrArray_VarOrArray::rewrite(rview kc_current_view_base)
{
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    arrayList l_arrayList_1 =
	arrayList_1->rewrite(kc_current_view_base);
    if ((l_casestring_1 == casestring_1) &&  (l_arrayList_1 == arrayList_1))
	return this;
    else {
	impl_varOrArray_VarOrArray* kc_result= VarOrArray(l_casestring_1, l_arrayList_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

arrayList impl_arrayList_ArrayList::rewrite(rview kc_current_view_base)
{
    arrayList l_arrayList_1 =
	arrayList_1->rewrite(kc_current_view_base);
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_arrayList_1 == arrayList_1) &&  (l_expression_1 == expression_1))
	return this;
    else {
	impl_arrayList_ArrayList* kc_result= ArrayList(l_arrayList_1, l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

arrayList impl_arrayList_EmptyArrayList::rewrite(rview kc_current_view_base)
{
    return this;

}

functionParametersList impl_functionParametersList_FunctionParametersList::rewrite(rview kc_current_view_base)
{
    functionParameters l_functionParameters_1 =
	functionParameters_1->rewrite(kc_current_view_base);
    functionParametersList l_functionParametersList_1 =
	functionParametersList_1->rewrite(kc_current_view_base);
    if ((l_functionParameters_1 == functionParameters_1) &&  (l_functionParametersList_1 == functionParametersList_1))
	return this;
    else {
	impl_functionParametersList_FunctionParametersList* kc_result= FunctionParametersList(l_functionParameters_1, l_functionParametersList_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

functionParametersList impl_functionParametersList_EmptyFunctionParametersList::rewrite(rview kc_current_view_base)
{
    return this;

}

functionParameters impl_functionParameters_FunctionParameters::rewrite(rview kc_current_view_base)
{
    type l_type_1 =
	type_1->rewrite(kc_current_view_base);
    varOrArray l_varOrArray_1 =
	varOrArray_1->rewrite(kc_current_view_base);
    if ((l_type_1 == type_1) &&  (l_varOrArray_1 == varOrArray_1))
	return this;
    else {
	impl_functionParameters_FunctionParameters* kc_result= FunctionParameters(l_type_1, l_varOrArray_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprAll::rewrite(rview kc_current_view_base)
{
    type l_type_1 =
	type_1->rewrite(kc_current_view_base);
    if ((l_type_1 == type_1))
	return this;
    else {
	impl_expression_ExprAll* kc_result= ExprAll(l_type_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprOtherIf::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    expression l_expression_3 =
	expression_3->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2) &&  (l_expression_3 == expression_3))
	return this;
    else {
	impl_expression_ExprOtherIf* kc_result= ExprOtherIf(l_expression_1, l_expression_2, l_expression_3);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprCommaSeparated::rewrite(rview kc_current_view_base)
{
    expressionlist l_expressionlist_1 =
	expressionlist_1->rewrite(kc_current_view_base);
    if ((l_expressionlist_1 == expressionlist_1))
	return this;
    else {
	impl_expression_ExprCommaSeparated* kc_result= ExprCommaSeparated(l_expressionlist_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_FunctionCall::rewrite(rview kc_current_view_base)
{
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    expressionlist l_expressionlist_1 =
	expressionlist_1->rewrite(kc_current_view_base);
    if ((l_casestring_1 == casestring_1) &&  (l_expressionlist_1 == expressionlist_1))
	return this;
    else {
	impl_expression_FunctionCall* kc_result= FunctionCall(l_casestring_1, l_expressionlist_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprGreaterOrEqual::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2))
	return this;
    else {
	impl_expression_ExprGreaterOrEqual* kc_result= ExprGreaterOrEqual(l_expression_1, l_expression_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprLessOrEqual::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2))
	return this;
    else {
	impl_expression_ExprLessOrEqual* kc_result= ExprLessOrEqual(l_expression_1, l_expression_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprGreaterThan::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2))
	return this;
    else {
	impl_expression_ExprGreaterThan* kc_result= ExprGreaterThan(l_expression_1, l_expression_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprLessThan::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2))
	return this;
    else {
	impl_expression_ExprLessThan* kc_result= ExprLessThan(l_expression_1, l_expression_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprNotEqual::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2))
	return this;
    else {
	impl_expression_ExprNotEqual* kc_result= ExprNotEqual(l_expression_1, l_expression_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprEquivalent::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2))
	return this;
    else {
	impl_expression_ExprEquivalent* kc_result= ExprEquivalent(l_expression_1, l_expression_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprFalse::rewrite(rview kc_current_view_base)
{
    return this;

}

expression impl_expression_ExprTrue::rewrite(rview kc_current_view_base)
{
    return this;

}

expression impl_expression_ExprOr::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2))
	return this;
    else {
	impl_expression_ExprOr* kc_result= ExprOr(l_expression_1, l_expression_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprAnd::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2))
	return this;
    else {
	impl_expression_ExprAnd* kc_result= ExprAnd(l_expression_1, l_expression_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_NotExpr::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1))
	return this;
    else {
	impl_expression_NotExpr* kc_result= NotExpr(l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprNumber::rewrite(rview kc_current_view_base)
{
    integer l_integer_1 =
	integer_1->rewrite(kc_current_view_base);
    if ((l_integer_1 == integer_1))
	return this;
    else {
	impl_expression_ExprNumber* kc_result= ExprNumber(l_integer_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprModulo::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2))
	return this;
    else {
	impl_expression_ExprModulo* kc_result= ExprModulo(l_expression_1, l_expression_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprDivision::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2))
	return this;
    else {
	impl_expression_ExprDivision* kc_result= ExprDivision(l_expression_1, l_expression_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprMultiplication::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2))
	return this;
    else {
	impl_expression_ExprMultiplication* kc_result= ExprMultiplication(l_expression_1, l_expression_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprSubtraction::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2))
	return this;
    else {
	impl_expression_ExprSubtraction* kc_result= ExprSubtraction(l_expression_1, l_expression_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprAddition::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2))
	return this;
    else {
	impl_expression_ExprAddition* kc_result= ExprAddition(l_expression_1, l_expression_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_NegativeExpr::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1))
	return this;
    else {
	impl_expression_NegativeExpr* kc_result= NegativeExpr(l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_PositiveExpr::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1))
	return this;
    else {
	impl_expression_PositiveExpr* kc_result= PositiveExpr(l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ValDecrement::rewrite(rview kc_current_view_base)
{
    leftvalue l_leftvalue_1 =
	leftvalue_1->rewrite(kc_current_view_base);
    if ((l_leftvalue_1 == leftvalue_1))
	return this;
    else {
	impl_expression_ValDecrement* kc_result= ValDecrement(l_leftvalue_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ValIncrement::rewrite(rview kc_current_view_base)
{
    leftvalue l_leftvalue_1 =
	leftvalue_1->rewrite(kc_current_view_base);
    if ((l_leftvalue_1 == leftvalue_1))
	return this;
    else {
	impl_expression_ValIncrement* kc_result= ValIncrement(l_leftvalue_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_DecrementVal::rewrite(rview kc_current_view_base)
{
    leftvalue l_leftvalue_1 =
	leftvalue_1->rewrite(kc_current_view_base);
    if ((l_leftvalue_1 == leftvalue_1))
	return this;
    else {
	impl_expression_DecrementVal* kc_result= DecrementVal(l_leftvalue_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_IncrementVal::rewrite(rview kc_current_view_base)
{
    leftvalue l_leftvalue_1 =
	leftvalue_1->rewrite(kc_current_view_base);
    if ((l_leftvalue_1 == leftvalue_1))
	return this;
    else {
	impl_expression_IncrementVal* kc_result= IncrementVal(l_leftvalue_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_AssignMod::rewrite(rview kc_current_view_base)
{
    leftvalue l_leftvalue_1 =
	leftvalue_1->rewrite(kc_current_view_base);
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_leftvalue_1 == leftvalue_1) &&  (l_expression_1 == expression_1))
	return this;
    else {
	impl_expression_AssignMod* kc_result= AssignMod(l_leftvalue_1, l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_AssignDivide::rewrite(rview kc_current_view_base)
{
    leftvalue l_leftvalue_1 =
	leftvalue_1->rewrite(kc_current_view_base);
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_leftvalue_1 == leftvalue_1) &&  (l_expression_1 == expression_1))
	return this;
    else {
	impl_expression_AssignDivide* kc_result= AssignDivide(l_leftvalue_1, l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_AssignTimes::rewrite(rview kc_current_view_base)
{
    leftvalue l_leftvalue_1 =
	leftvalue_1->rewrite(kc_current_view_base);
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_leftvalue_1 == leftvalue_1) &&  (l_expression_1 == expression_1))
	return this;
    else {
	impl_expression_AssignTimes* kc_result= AssignTimes(l_leftvalue_1, l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_AssignMinus::rewrite(rview kc_current_view_base)
{
    leftvalue l_leftvalue_1 =
	leftvalue_1->rewrite(kc_current_view_base);
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_leftvalue_1 == leftvalue_1) &&  (l_expression_1 == expression_1))
	return this;
    else {
	impl_expression_AssignMinus* kc_result= AssignMinus(l_leftvalue_1, l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_AssignPlus::rewrite(rview kc_current_view_base)
{
    leftvalue l_leftvalue_1 =
	leftvalue_1->rewrite(kc_current_view_base);
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_leftvalue_1 == leftvalue_1) &&  (l_expression_1 == expression_1))
	return this;
    else {
	impl_expression_AssignPlus* kc_result= AssignPlus(l_leftvalue_1, l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_AssignEqual::rewrite(rview kc_current_view_base)
{
    leftvalue l_leftvalue_1 =
	leftvalue_1->rewrite(kc_current_view_base);
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_leftvalue_1 == leftvalue_1) &&  (l_expression_1 == expression_1))
	return this;
    else {
	impl_expression_AssignEqual* kc_result= AssignEqual(l_leftvalue_1, l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprInitializerList::rewrite(rview kc_current_view_base)
{
    initializerList l_initializerList_1 =
	initializerList_1->rewrite(kc_current_view_base);
    if ((l_initializerList_1 == initializerList_1))
	return this;
    else {
	impl_expression_ExprInitializerList* kc_result= ExprInitializerList(l_initializerList_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprLeftvalue::rewrite(rview kc_current_view_base)
{
    leftvalue l_leftvalue_1 =
	leftvalue_1->rewrite(kc_current_view_base);
    if ((l_leftvalue_1 == leftvalue_1))
	return this;
    else {
	impl_expression_ExprLeftvalue* kc_result= ExprLeftvalue(l_leftvalue_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

leftvalue impl_leftvalue_LeftValDot::rewrite(rview kc_current_view_base)
{
    leftvalue l_leftvalue_1 =
	leftvalue_1->rewrite(kc_current_view_base);
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    if ((l_leftvalue_1 == leftvalue_1) &&  (l_casestring_1 == casestring_1))
	return this;
    else {
	impl_leftvalue_LeftValDot* kc_result= LeftValDot(l_leftvalue_1, l_casestring_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

leftvalue impl_leftvalue_LeftValBrackets::rewrite(rview kc_current_view_base)
{
    leftvalue l_leftvalue_1 =
	leftvalue_1->rewrite(kc_current_view_base);
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_leftvalue_1 == leftvalue_1) &&  (l_expression_1 == expression_1))
	return this;
    else {
	impl_leftvalue_LeftValBrackets* kc_result= LeftValBrackets(l_leftvalue_1, l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

leftvalue impl_leftvalue_LeftValIdent::rewrite(rview kc_current_view_base)
{
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    if ((l_casestring_1 == casestring_1))
	return this;
    else {
	impl_leftvalue_LeftValIdent* kc_result= LeftValIdent(l_casestring_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expressionlist impl_expressionlist_ExpressionList::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expressionlist l_expressionlist_1 =
	expressionlist_1->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expressionlist_1 == expressionlist_1))
	return this;
    else {
	impl_expressionlist_ExpressionList* kc_result= ExpressionList(l_expression_1, l_expressionlist_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expressionlist impl_expressionlist_EmptyExpressionList::rewrite(rview kc_current_view_base)
{
    return this;

}

initializerList impl_initializerList_ExprInBracesColon::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    expressionListColon l_expressionListColon_1 =
	expressionListColon_1->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2) &&  (l_expressionListColon_1 == expressionListColon_1))
	return this;
    else {
	impl_initializerList_ExprInBracesColon* kc_result= ExprInBracesColon(l_expression_1, l_expression_2, l_expressionListColon_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

initializerList impl_initializerList_ExprInBraces::rewrite(rview kc_current_view_base)
{
    expressionlist l_expressionlist_1 =
	expressionlist_1->rewrite(kc_current_view_base);
    if ((l_expressionlist_1 == expressionlist_1))
	return this;
    else {
	impl_initializerList_ExprInBraces* kc_result= ExprInBraces(l_expressionlist_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expressionListColon impl_expressionListColon_ExpressionListColon::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    expressionListColon l_expressionListColon_1 =
	expressionListColon_1->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2) &&  (l_expressionListColon_1 == expressionListColon_1))
	return this;
    else {
	impl_expressionListColon_ExpressionListColon* kc_result= ExpressionListColon(l_expression_1, l_expression_2, l_expressionListColon_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expressionListColon impl_expressionListColon_EmptyExpressionListColon::rewrite(rview kc_current_view_base)
{
    return this;

}

placeblocklist impl_placeblocklist_PlaceBlockList::rewrite(rview kc_current_view_base)
{
    placeblock l_placeblock_1 =
	placeblock_1->rewrite(kc_current_view_base);
    placeblocklist l_placeblocklist_1 =
	placeblocklist_1->rewrite(kc_current_view_base);
    if ((l_placeblock_1 == placeblock_1) &&  (l_placeblocklist_1 == placeblocklist_1))
	return this;
    else {
	impl_placeblocklist_PlaceBlockList* kc_result= PlaceBlockList(l_placeblock_1, l_placeblocklist_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

placeblocklist impl_placeblocklist_EmptyPlaceBlockList::rewrite(rview kc_current_view_base)
{
    return this;

}

optSafe impl_optSafe_Safe::rewrite(rview kc_current_view_base)
{
    integer l_integer_1 =
	integer_1->rewrite(kc_current_view_base);
    if ((l_integer_1 == integer_1))
	return this;
    else {
	impl_optSafe_Safe* kc_result= Safe(l_integer_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

optSafe impl_optSafe_EmptySafe::rewrite(rview kc_current_view_base)
{
    return this;

}

place impl_place_Place::rewrite(rview kc_current_view_base)
{
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    if ((l_casestring_1 == casestring_1))
	return this;
    else {
	impl_place_Place* kc_result= Place(l_casestring_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

placelist impl_placelist_PlaceList::rewrite(rview kc_current_view_base)
{
    place l_place_1 =
	place_1->rewrite(kc_current_view_base);
    placelist l_placelist_1 =
	placelist_1->rewrite(kc_current_view_base);
    if ((l_place_1 == place_1) &&  (l_placelist_1 == placelist_1))
	return this;
    else {
	impl_placelist_PlaceList* kc_result= PlaceList(l_place_1, l_placelist_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

placelist impl_placelist_EmptyPlaceList::rewrite(rview kc_current_view_base)
{
    return this;

}

placeblock impl_placeblock_PlaceBlock::rewrite(rview kc_current_view_base)
{
    optSafe l_optSafe_1 =
	optSafe_1->rewrite(kc_current_view_base);
    type l_type_1 =
	type_1->rewrite(kc_current_view_base);
    placelist l_placelist_1 =
	placelist_1->rewrite(kc_current_view_base);
    if ((l_optSafe_1 == optSafe_1) &&  (l_type_1 == type_1) &&  (l_placelist_1 == placelist_1))
	return this;
    else {
	impl_placeblock_PlaceBlock* kc_result= PlaceBlock(l_optSafe_1, l_type_1, l_placelist_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

marking impl_marking_Marking::rewrite(rview kc_current_view_base)
{
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    marking l_marking_1 =
	marking_1->rewrite(kc_current_view_base);
    if ((l_casestring_1 == casestring_1) &&  (l_expression_1 == expression_1) &&  (l_marking_1 == marking_1))
	return this;
    else {
	impl_marking_Marking* kc_result= Marking(l_casestring_1, l_expression_1, l_marking_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

marking impl_marking_EmptyMarking::rewrite(rview kc_current_view_base)
{
    return this;

}

transition impl_transition_Transition::rewrite(rview kc_current_view_base)
{
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    fairness l_fairness_1 =
	fairness_1->rewrite(kc_current_view_base);
    variable l_variable_1 =
	variable_1->rewrite(kc_current_view_base);
    guard l_guard_1 =
	guard_1->rewrite(kc_current_view_base);
    identExprList l_identExprList_1 =
	identExprList_1->rewrite(kc_current_view_base);
    identExprList l_identExprList_2 =
	identExprList_2->rewrite(kc_current_view_base);
    transition l_transition_1 =
	transition_1->rewrite(kc_current_view_base);
    if ((l_casestring_1 == casestring_1) &&  (l_fairness_1 == fairness_1) &&  (l_variable_1 == variable_1) &&  (l_guard_1 == guard_1) &&  (l_identExprList_1 == identExprList_1) &&  (l_identExprList_2 == identExprList_2) &&  (l_transition_1 == transition_1))
	return this;
    else {
	impl_transition_Transition* kc_result= Transition(l_casestring_1, l_fairness_1, l_variable_1, l_guard_1, l_identExprList_1, l_identExprList_2, l_transition_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

transition impl_transition_EmptyTransition::rewrite(rview kc_current_view_base)
{
    return this;

}

fairness impl_fairness_StrongFair::rewrite(rview kc_current_view_base)
{
    return this;

}

fairness impl_fairness_WeakFair::rewrite(rview kc_current_view_base)
{
    return this;

}

fairness impl_fairness_EmptyFairness::rewrite(rview kc_current_view_base)
{
    return this;

}

variable impl_variable_Variable::rewrite(rview kc_current_view_base)
{
    type l_type_1 =
	type_1->rewrite(kc_current_view_base);
    varOrArrayList l_varOrArrayList_1 =
	varOrArrayList_1->rewrite(kc_current_view_base);
    variable l_variable_1 =
	variable_1->rewrite(kc_current_view_base);
    if ((l_type_1 == type_1) &&  (l_varOrArrayList_1 == varOrArrayList_1) &&  (l_variable_1 == variable_1))
	return this;
    else {
	impl_variable_Variable* kc_result= Variable(l_type_1, l_varOrArrayList_1, l_variable_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

variable impl_variable_EmptyVariable::rewrite(rview kc_current_view_base)
{
    return this;

}

varOrArrayList impl_varOrArrayList_VarOrArrayList::rewrite(rview kc_current_view_base)
{
    varOrArray l_varOrArray_1 =
	varOrArray_1->rewrite(kc_current_view_base);
    varOrArrayList l_varOrArrayList_1 =
	varOrArrayList_1->rewrite(kc_current_view_base);
    if ((l_varOrArray_1 == varOrArray_1) &&  (l_varOrArrayList_1 == varOrArrayList_1))
	return this;
    else {
	impl_varOrArrayList_VarOrArrayList* kc_result= VarOrArrayList(l_varOrArray_1, l_varOrArrayList_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

varOrArrayList impl_varOrArrayList_EmptyVarOrArrayList::rewrite(rview kc_current_view_base)
{
    return this;

}

guard impl_guard_Guard::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1))
	return this;
    else {
	impl_guard_Guard* kc_result= Guard(l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

identExprList impl_identExprList_IdentExprList::rewrite(rview kc_current_view_base)
{
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    identExprList l_identExprList_1 =
	identExprList_1->rewrite(kc_current_view_base);
    if ((l_casestring_1 == casestring_1) &&  (l_expression_1 == expression_1) &&  (l_identExprList_1 == identExprList_1))
	return this;
    else {
	impl_identExprList_IdentExprList* kc_result= IdentExprList(l_casestring_1, l_expression_1, l_identExprList_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

identExprList impl_identExprList_EmptyIdentExprList::rewrite(rview kc_current_view_base)
{
    return this;

}

block impl_block_Block::rewrite(rview kc_current_view_base)
{
    declarationOrStatement l_declarationOrStatement_1 =
	declarationOrStatement_1->rewrite(kc_current_view_base);
    if ((l_declarationOrStatement_1 == declarationOrStatement_1))
	return this;
    else {
	impl_block_Block* kc_result= Block(l_declarationOrStatement_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

declarationOrStatement impl_declarationOrStatement_DeclOrStatemStatement::rewrite(rview kc_current_view_base)
{
    statement l_statement_1 =
	statement_1->rewrite(kc_current_view_base);
    declarationOrStatement l_declarationOrStatement_1 =
	declarationOrStatement_1->rewrite(kc_current_view_base);
    if ((l_statement_1 == statement_1) &&  (l_declarationOrStatement_1 == declarationOrStatement_1))
	return this;
    else {
	impl_declarationOrStatement_DeclOrStatemStatement* kc_result= DeclOrStatemStatement(l_statement_1, l_declarationOrStatement_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

declarationOrStatement impl_declarationOrStatement_DeclOrStatemDeclaration::rewrite(rview kc_current_view_base)
{
    declaration l_declaration_1 =
	declaration_1->rewrite(kc_current_view_base);
    declarationOrStatement l_declarationOrStatement_1 =
	declarationOrStatement_1->rewrite(kc_current_view_base);
    if ((l_declaration_1 == declaration_1) &&  (l_declarationOrStatement_1 == declarationOrStatement_1))
	return this;
    else {
	impl_declarationOrStatement_DeclOrStatemDeclaration* kc_result= DeclOrStatemDeclaration(l_declaration_1, l_declarationOrStatement_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

declarationOrStatement impl_declarationOrStatement_EmptyDeclarationOrStatement::rewrite(rview kc_current_view_base)
{
    return this;

}

declaration impl_declaration_Declaration::rewrite(rview kc_current_view_base)
{
    type l_type_1 =
	type_1->rewrite(kc_current_view_base);
    varOrArrayList l_varOrArrayList_1 =
	varOrArrayList_1->rewrite(kc_current_view_base);
    if ((l_type_1 == type_1) &&  (l_varOrArrayList_1 == varOrArrayList_1))
	return this;
    else {
	impl_declaration_Declaration* kc_result= Declaration(l_type_1, l_varOrArrayList_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

statement impl_statement_StatementSkip::rewrite(rview kc_current_view_base)
{
    return this;

}

statement impl_statement_StatementReturn::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1))
	return this;
    else {
	impl_statement_StatementReturn* kc_result= StatementReturn(l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

statement impl_statement_StatementContinue::rewrite(rview kc_current_view_base)
{
    return this;

}

statement impl_statement_StatementBreak::rewrite(rview kc_current_view_base)
{
    return this;

}

statement impl_statement_StatementSwitch::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    switchCaseList l_switchCaseList_1 =
	switchCaseList_1->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_switchCaseList_1 == switchCaseList_1))
	return this;
    else {
	impl_statement_StatementSwitch* kc_result= StatementSwitch(l_expression_1, l_switchCaseList_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

statement impl_statement_StatementForAll::rewrite(rview kc_current_view_base)
{
    type l_type_1 =
	type_1->rewrite(kc_current_view_base);
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    type l_type_2 =
	type_2->rewrite(kc_current_view_base);
    if ((l_type_1 == type_1) &&  (l_casestring_1 == casestring_1) &&  (l_type_2 == type_2))
	return this;
    else {
	impl_statement_StatementForAll* kc_result= StatementForAll(l_type_1, l_casestring_1, l_type_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

statement impl_statement_StatementForIdentColon::rewrite(rview kc_current_view_base)
{
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    statement l_statement_1 =
	statement_1->rewrite(kc_current_view_base);
    if ((l_casestring_1 == casestring_1) &&  (l_expression_1 == expression_1) &&  (l_statement_1 == statement_1))
	return this;
    else {
	impl_statement_StatementForIdentColon* kc_result= StatementForIdentColon(l_casestring_1, l_expression_1, l_statement_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

statement impl_statement_StatementForTypeExpr::rewrite(rview kc_current_view_base)
{
    type l_type_1 =
	type_1->rewrite(kc_current_view_base);
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    expression l_expression_3 =
	expression_3->rewrite(kc_current_view_base);
    statement l_statement_1 =
	statement_1->rewrite(kc_current_view_base);
    if ((l_type_1 == type_1) &&  (l_casestring_1 == casestring_1) &&  (l_expression_1 == expression_1) &&  (l_expression_2 == expression_2) &&  (l_expression_3 == expression_3) &&  (l_statement_1 == statement_1))
	return this;
    else {
	impl_statement_StatementForTypeExpr* kc_result= StatementForTypeExpr(l_type_1, l_casestring_1, l_expression_1, l_expression_2, l_expression_3, l_statement_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

statement impl_statement_StatementForExpr::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    expression l_expression_3 =
	expression_3->rewrite(kc_current_view_base);
    statement l_statement_1 =
	statement_1->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2) &&  (l_expression_3 == expression_3) &&  (l_statement_1 == statement_1))
	return this;
    else {
	impl_statement_StatementForExpr* kc_result= StatementForExpr(l_expression_1, l_expression_2, l_expression_3, l_statement_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

statement impl_statement_StatementDoWhile::rewrite(rview kc_current_view_base)
{
    statement l_statement_1 =
	statement_1->rewrite(kc_current_view_base);
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_statement_1 == statement_1) &&  (l_expression_1 == expression_1))
	return this;
    else {
	impl_statement_StatementDoWhile* kc_result= StatementDoWhile(l_statement_1, l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

statement impl_statement_StatementWhile::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    statement l_statement_1 =
	statement_1->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_statement_1 == statement_1))
	return this;
    else {
	impl_statement_StatementWhile* kc_result= StatementWhile(l_expression_1, l_statement_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

statement impl_statement_StatementIf::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    statement l_statement_1 =
	statement_1->rewrite(kc_current_view_base);
    statement l_statement_2 =
	statement_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_statement_1 == statement_1) &&  (l_statement_2 == statement_2))
	return this;
    else {
	impl_statement_StatementIf* kc_result= StatementIf(l_expression_1, l_statement_1, l_statement_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

statement impl_statement_StatementExprSemicolon::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1))
	return this;
    else {
	impl_statement_StatementExprSemicolon* kc_result= StatementExprSemicolon(l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

statement impl_statement_StatementBlock::rewrite(rview kc_current_view_base)
{
    block l_block_1 =
	block_1->rewrite(kc_current_view_base);
    if ((l_block_1 == block_1))
	return this;
    else {
	impl_statement_StatementBlock* kc_result= StatementBlock(l_block_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

switchCase impl_switchCase_SwitchDefault::rewrite(rview kc_current_view_base)
{
    statement l_statement_1 =
	statement_1->rewrite(kc_current_view_base);
    if ((l_statement_1 == statement_1))
	return this;
    else {
	impl_switchCase_SwitchDefault* kc_result= SwitchDefault(l_statement_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

switchCase impl_switchCase_SwitchCase::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    statement l_statement_1 =
	statement_1->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_statement_1 == statement_1))
	return this;
    else {
	impl_switchCase_SwitchCase* kc_result= SwitchCase(l_expression_1, l_statement_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

switchCaseList impl_switchCaseList_SwitchCaseList::rewrite(rview kc_current_view_base)
{
    switchCase l_switchCase_1 =
	switchCase_1->rewrite(kc_current_view_base);
    switchCaseList l_switchCaseList_1 =
	switchCaseList_1->rewrite(kc_current_view_base);
    if ((l_switchCase_1 == switchCase_1) &&  (l_switchCaseList_1 == switchCaseList_1))
	return this;
    else {
	impl_switchCaseList_SwitchCaseList* kc_result= SwitchCaseList(l_switchCase_1, l_switchCaseList_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

switchCaseList impl_switchCaseList_EmptySwitchCaseList::rewrite(rview kc_current_view_base)
{
    return this;

}

} // namespace kc
